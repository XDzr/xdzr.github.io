<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CAN开发流程</title>
    <url>/2024/01/23/CAN%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="修改设备树"><a href="#修改设备树" class="headerlink" title="修改设备树"></a>修改设备树</h3><h4 id="1、FlexCAN1-引脚节点信息"><a href="#1、FlexCAN1-引脚节点信息" class="headerlink" title="1、FlexCAN1 引脚节点信息"></a>1、FlexCAN1 引脚节点信息</h4><p>首先是 CAN1 引脚配置信息：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_flexcan1: flexcan1grp&#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX <span class="number">0x1b020</span></span><br><span class="line">MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX <span class="number">0x1b020</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、FlexCAN1-控制器节点信息"><a href="#2、FlexCAN1-控制器节点信息" class="headerlink" title="2、FlexCAN1 控制器节点信息"></a>2、FlexCAN1 控制器节点信息</h4><p>&amp;flexcan1 {<br>pinctrl-names &#x3D; “default”;<br>pinctrl-0 &#x3D; &lt;&amp;pinctrl_flexcan1&gt;;<br>xceiver-supply &#x3D; &lt;&amp;reg_can_3v3&gt;;<br>status &#x3D; “okay”;<br>};</p>
<h4 id="3、使能-Linux-内核自带的-FlexCAN-驱动"><a href="#3、使能-Linux-内核自带的-FlexCAN-驱动" class="headerlink" title="3、使能 Linux 内核自带的 FlexCAN 驱动"></a>3、使能 Linux 内核自带的 FlexCAN 驱动</h4><ol>
<li>使能 CAN 总线:首先打开 CAN 总线子系统，在 Linux 下 CAN 总线是作为网络子系统的，打开CAN bus subsystem support</li>
<li>使能 Freescale 系 CPU 的 FlexCAN 外设驱动，</li>
</ol>
<h4 id="4、FlexCAN-测试"><a href="#4、FlexCAN-测试" class="headerlink" title="4、FlexCAN 测试"></a>4、FlexCAN 测试</h4><ol>
<li>检查 CAN 网卡设备是否存在：ifconfig -a</li>
<li>移植 iproute2</li>
<li>移植 can-utils 工具</li>
<li>回环测试：在一个板子上进行 CAN 回环测试，自己给自己发送数据并接受</li>
</ol>
<h4 id="5、应用程序"><a href="#5、应用程序" class="headerlink" title="5、应用程序"></a>5、应用程序</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_can_frame</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> can_id, <span class="type">int</span> can_data_len, <span class="type">unsigned</span> <span class="type">char</span>* can_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span>      <span class="comment">//用于存储与CAN设备相关的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span>              <span class="comment">//用于存储获取到的CAN设备的信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ifname = <span class="string">&quot;can0&quot;</span>;   <span class="comment">// CAN 设备名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error while opening socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ioctl() 函数获取CAN设备的接口索引，并将其存储在 ifr.ifr_ifindex 中。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, ifname);</span><br><span class="line">    ioctl(s, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与 CAN 设备绑定</span></span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="keyword">if</span> (bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in socket bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备要发送的数据帧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    frame.can_id = can_id;    <span class="comment">// CAN ID</span></span><br><span class="line">    frame.can_dlc = can_data_len;  <span class="comment">// 数据长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(frame.data, can_data, can_data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据帧</span></span><br><span class="line">    <span class="type">int</span> nbytes = write(s, &amp;frame, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> can_frame));</span><br><span class="line">    <span class="keyword">if</span> (nbytes != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> can_frame)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in sending CAN frame&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent CAN frame with ID 0x%03X\n&quot;</span>, frame.can_id);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Error: Spawn failed解决办法</title>
    <url>/2023/12/17/Error-Spawn-failed%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>在创建的blog文件夹（即最早建的最大的文件夹）中找到_config.yml，把deploy板块中的repository换成ssh地址</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">repository: 此处填ssh地址</span><br></pre></td></tr></table></figure></div>
<p>如果没有添加过密钥，则前往GitHub的个人设置（点击右上角头像旁边的小三角—&gt;settings)，点击SSH and GPG;在本地通过git生成密钥后再复制并添加到ssh keys中即可。</p>
<h3 id="solution-2："><a href="#solution-2：" class="headerlink" title="solution 2："></a>solution 2：</h3><p>还是在blog文件夹下，删除名为.deploy_git的文件夹，在Windows下操作如下(打开cmd管理员模式)：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">F:  (进入某盘)</span><br><span class="line">cd yourblog/  (进入你的博客文件夹)</span><br><span class="line">rd /s .deploy_git  (删除该文件)</span><br></pre></td></tr></table></figure></div>
<p>然后在git命令行中执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure></div>
<p>然后再走一遍流程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN总线难点</title>
    <url>/2024/01/18/CAN%E6%80%BB%E7%BA%BF%E9%9A%BE%E7%82%B9/</url>
    <content><![CDATA[<h3 id="带宽和速率管理："><a href="#带宽和速率管理：" class="headerlink" title="带宽和速率管理："></a>带宽和速率管理：</h3><p>CAN 总线通常用于连接多个节点，这些节点可能会发送大量的数据，<br>因此需要有效地管理带宽和数据传输速率。特别是在高速 CAN 中，<br>如何确保数据在高速传输中的可靠性和实时性是一个挑战。</p>
<ol>
<li>使用错误检测和纠正机制：CAN协议通常使用CRC（循环冗余校验）来检测数据传输中的错误，并且一些应用可能会使用更高级别的纠错码（如重复码或汉明码）来进行错误纠正。</li>
<li>优先级机制：CAN协议支持消息的优先级。通过正确设置消息的优先级，可以确保重要数据优先发送，从而提高实时性。</li>
</ol>
<h3 id="网络管理和拓扑结构："><a href="#网络管理和拓扑结构：" class="headerlink" title="网络管理和拓扑结构："></a>网络管理和拓扑结构：</h3><p>设计一个复杂的 CAN 网络需要考虑节点之间的连接方式、拓扑结构和通信规则等。这涉及到网络拓扑设计、节点分配和通信规则制定等方面的工作。</p>
<h3 id="故障诊断和容错机制："><a href="#故障诊断和容错机制：" class="headerlink" title="故障诊断和容错机制："></a>故障诊断和容错机制：</h3><ol>
<li><p>自动重传机制：CAN总线上的节点在发送消息时，会监视总线上的确认位（ACK）。如果节点没有收到ACK，它将自动重试发送消息，直到收到ACK或者达到最大重试次数。这种机制确保了消息的可靠传输。</p>
</li>
<li><p>错误帧和错误报告：CAN总线上的节点会监视错误帧，这些错误帧会在总线上传输，用于表示数据传输过程中的错误。节点可以根据收到的错误帧来检测总线上的错误，并将错误信息报告给系统的上层。</p>
</li>
<li><p>错误标识符：CAN总线上的每个节点都有一个唯一的标识符（ID），用于识别消息的发送者和接收者。如果节点收到了具有错误标识符的消息，它将忽略该消息，并将错误信息报告给系统的上层。</p>
</li>
</ol>
<h3 id="如何确保你的CAN发送和接收代码正确"><a href="#如何确保你的CAN发送和接收代码正确" class="headerlink" title="如何确保你的CAN发送和接收代码正确"></a>如何确保你的CAN发送和接收代码正确</h3><ol>
<li>硬件连接：确认CAN控制器与CAN总线连接正确，确保电源、地线和信号线连接正确并且稳定。</li>
<li>使用示波器或CAN分析仪：使用示波器或专用的CAN分析仪来监视CAN总线上的信号。你可以验证发送消息的波形是否正确，以及接收消息时是否出现预期的波形。</li>
<li>通过电压表测试两根线之间的电压可以帮助你判断是否有数据发送。在CAN总线中，当节点发送数据时，会在总线上产生电压差，这可以通过测量两根线之间的电压来检测。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下查看内存使用情况方法</title>
    <url>/2024/02/01/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1、atop"><a href="#1、atop" class="headerlink" title="1、atop"></a>1、atop</h3><p>atop命令是一个终端环境的监控命令。它显示的是各种系统资源（CPU, memory, network, I&#x2F;O, kernel）的综合，并且在高负载的情况下进行了彩色标注。<br>$ sudo atop</p>
<h3 id="2、free"><a href="#2、free" class="headerlink" title="2、free"></a>2、free</h3><p>free命令是一个快速查看内存使用情况的方法，它是对 &#x2F;proc&#x2F;meminfo 收集到的信息的一个概述。<br>$ free -h</p>
<h3 id="3、htop"><a href="#3、htop" class="headerlink" title="3、htop"></a>3、htop</h3><p>htop命令显示了每个进程的内存实时使用率。它提供了所有进程的常驻内存大小、程序总内存大小、共享库大小等的报告。列表可以水平及垂直滚动。<br>$ htop</p>
<h3 id="4、ps"><a href="#4、ps" class="headerlink" title="4、ps"></a>4、ps</h3><p>ps命令可以实时的显示各个进程的内存使用情况。Reported memory usage information includes %MEM (percent of physical memory used), VSZ (total amount of virtual memory used), and RSS (total amount of physical memory used)。你可以使用 “–sort”选项对进程进行排序，例如按RSS进行排序：<br>$ ps aux –sort -rss</p>
<h3 id="5、11-top"><a href="#5、11-top" class="headerlink" title="5、11.top"></a>5、11.top</h3><p>top命令提供了实时的运行中的程序的资源使用统计。你可以根据内存的使用和大小来进行排序。<br>$ top</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下驱动和应用之间的联系</title>
    <url>/2024/01/22/Linux%E4%B8%8B%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="一、在Linux下，驱动程序是如何与应用程序相联系的"><a href="#一、在Linux下，驱动程序是如何与应用程序相联系的" class="headerlink" title="一、在Linux下，驱动程序是如何与应用程序相联系的"></a>一、在Linux下，驱动程序是如何与应用程序相联系的</h2><h3 id="创建设备文件："><a href="#创建设备文件：" class="headerlink" title="创建设备文件："></a>创建设备文件：</h3><p>在驱动程序的 probe 函数中，会调用函数 device_create() 来创建设备文件，该函数会在 &#x2F;dev 目录下创建一个设备文件，使得应用程序可以通过该设备文件与驱动程序进行通信。</p>
<h3 id="打开设备文件："><a href="#打开设备文件：" class="headerlink" title="打开设备文件："></a>打开设备文件：</h3><p>应用程序可以使用系统调用 open() 打开设备文件，获取与之关联的文件描述符。在驱动程序中，当调用 open 函数时，内核会调用驱动程序中的 open 函数，从而进行设备的初始化等操作。</p>
<h3 id="读写设备文件："><a href="#读写设备文件：" class="headerlink" title="读写设备文件："></a>读写设备文件：</h3><p>应用程序可以使用系统调用 read() 和 write() 来读写设备文件。在驱动程序中，当应用程序调用 read() 或 write() 函数时，内核会调用驱动程序中相应的读取或写入函数，从而对设备进行相应的读写操作。</p>
<h3 id="关闭设备文件："><a href="#关闭设备文件：" class="headerlink" title="关闭设备文件："></a>关闭设备文件：</h3><p>应用程序可以使用系统调用 close() 关闭设备文件。在驱动程序中，当应用程序调用 close() 函数时，内核会调用驱动程序中的 release 函数，执行设备的释放操作。</p>
<h2 id="二、为什么I2C和SPI等要分为适配器驱动和设备驱动？"><a href="#二、为什么I2C和SPI等要分为适配器驱动和设备驱动？" class="headerlink" title="二、为什么I2C和SPI等要分为适配器驱动和设备驱动？"></a>二、为什么I2C和SPI等要分为适配器驱动和设备驱动？</h2><h3 id="设备驱动："><a href="#设备驱动：" class="headerlink" title="设备驱动："></a>设备驱动：</h3><ol>
<li>设备驱动是针对具体的I2C、SPI设备编写的，用于控制和管理这些设备。</li>
<li>设备驱动通常由硬件设备的制造商或硬件厂商的工程师编写，因为他们了解设备的规格和特性。</li>
<li>设备驱动负责处理与设备相关的操作，如数据的读写、寄存器的设置等。</li>
</ol>
<h3 id="适配器驱动："><a href="#适配器驱动：" class="headerlink" title="适配器驱动："></a>适配器驱动：</h3><ol>
<li>适配器驱动是针对I2C、SPI等总线控制器的驱动程序，用于管理总线控制器的操作。</li>
<li>适配器驱动通常由Linux内核开发人员或芯片厂商提供，并包含在Linux内核中。</li>
<li>适配器驱动负责与硬件总线控制器进行通信，控制总线的初始化、数据传输等操作。</li>
</ol>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ol>
<li>设备驱动与具体的设备相关联，因此将设备驱动分离出来，便于管理和维护。</li>
<li>适配器驱动管理总线控制器，因此与硬件平台相关联，通常由操作系统或芯片厂商提供，以确保与硬件的兼容性和稳定性。</li>
<li>这种分离的设计使得Linux内核的驱动开发更加灵活，可以针对不同的设备和硬件平台编写对应的驱动程序，并且能够在不同的硬件上实现相同的接口和功能。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核源码的Makefile、Kconfig和.config文件</title>
    <url>/2024/02/11/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84Makefile%E3%80%81Kconfig%E5%92%8C-config%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="一、三者的作用"><a href="#一、三者的作用" class="headerlink" title="一、三者的作用"></a>一、三者的作用</h3><ol>
<li>Makefile：一个文本形式的文件，编译源文件的方法。</li>
<li>Kconfig：一个文本形式的文件，内核的配置菜单。</li>
<li>.config：编译内核所依据的配置。<br>可以理解为：Kconfig是菜单，Makefile是做法，.config就是你点的菜。</li>
</ol>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><h4 id="1、Makefile"><a href="#1、Makefile" class="headerlink" title="1、Makefile"></a>1、Makefile</h4><p>用来定义哪些内容作为模块编译，哪些条件编译等。子目录Makefile被顶层Makefile包含。</p>
<ol>
<li><p>直接编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y      += xxx.o                </span><br></pre></td></tr></table></figure></div>
<p>表示由xxx.c或xxx.s编译得到xxx.o并直接编进内核。</p>
</li>
<li><p>条件编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj -$(CONFIG_HELLO)  += xxx.o   </span><br></pre></td></tr></table></figure></div>
<p>根据.config文件的CONFIG_XXX来决定文件是否编进内核。</p>
</li>
<li><p>模块编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m     +=xxx.o</span><br></pre></td></tr></table></figure></div>
<p>表示xxx作为模块编译，即执行make modules时才会被编译。</p>
</li>
</ol>
<h4 id="2、Kconfig"><a href="#2、Kconfig" class="headerlink" title="2、Kconfig"></a>2、Kconfig</h4><p>每个config菜单项都有类型定义: bool布尔类型、 tristate三态(内建、模块、移除)、string字符串、 hex十六进制、integer整型。<br>作用：决定make menuconfig时展示的菜单项</p>
<h4 id="3、-config"><a href="#3、-config" class="headerlink" title="3、.config"></a>3、.config</h4><p>通过前俩个文件的分析，.config的含义已经很清晰：内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核。<br>配置内核方式有3种(任选其一)：</p>
<ol>
<li>make menuconfig</li>
<li>make xxx_defconfig</li>
<li>直接修改.config</li>
</ol>
<h3 id="三、举例说明"><a href="#三、举例说明" class="headerlink" title="三、举例说明"></a>三、举例说明</h3><p>写一个简单的入口函数输出hello world的驱动并编译进内核。<br>步骤：</p>
<ol>
<li>在drivers目录下新建hello文件夹，里面实现hello.c、Makefile、Kconfig。</li>
</ol>
<p><strong>hello.c：</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">first_drv_init</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="built_in">printk</span>(<span class="string">&quot;------------------hello world !--------------------&quot;</span>);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">first_drv_exit</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;------------------exit hello world !--------------------&quot;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">module_init</span>(first_drv_init); </span><br><span class="line"><span class="built_in">module_exit</span>(first_drv_exit); </span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>Makefile：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_HELLO)         += hello.o  </span><br></pre></td></tr></table></figure></div>

<p><strong>Kconfig：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">config HELLO  </span><br><span class="line">   tristate &quot;ZR&quot;  </span><br><span class="line">   help  </span><br><span class="line">    ZR  </span><br></pre></td></tr></table></figure></div>
<p>config HELLO决定名字：CONFIG_HELLO。<br>ZR：决定了在make menuconfig时显示的名字</p>
<ol start="2">
<li>修改上一级（Linux-3.4.2&#x2F;drivers下）的Makefile、Kconfig。</li>
</ol>
<p><strong>Makefile：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y  += hello/  </span><br></pre></td></tr></table></figure></div>


<p><strong>Kconfig：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">source  &quot;drivers/hello/Kconfig&quot;  </span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>make menuconfig</li>
<li>make uImage再烧写到开发板。</li>
</ol>
<p>查看内核启动Log，显示helloworld，说明hello.c成功编进内核</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>用户通过 Kconfig 进行内核配置，选择需要的功能和选项。</li>
<li>用户的配置选择会被保存到 .config 文件中。</li>
<li>Makefile 会在构建内核时使用 .config 文件中的配置选项，根据用户的配置生成相应的内核映像和模块。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动开发常用函数</title>
    <url>/2024/02/27/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap"></a>ioremap</h3><p>ioremap是Linux内核中的一个函数，用于将物理地址映射到内核的虚拟地址空间，以便内核可以直接访问设备的寄存器或内存区域。它通常用于设备驱动程序中，特别是在需要直接访问设备内存或寄存器时。</p>
<h4 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * offset：要映射的物理地址的偏移量。</span></span><br><span class="line"><span class="comment"> * size：要映射的区域大小。</span></span><br><span class="line"><span class="comment"> * void __iomem *：映射后的虚拟地址，通常是volatile类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> __iomem *<span class="title">ioremap</span><span class="params">(<span class="type">phys_addr_t</span> offset, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pathname ：文件的名称，可以包含（绝对和相对）路径</span></span><br><span class="line"><span class="comment"> * flags：文件打开模式</span></span><br><span class="line"><span class="comment"> * mode: 用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * pathname,<span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></div>


<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p>
<h4 id="函数定义-1"><a href="#函数定义-1" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为* 0, 则read()不会有作用并返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内。</p>
<h4 id="函数定义-2"><a href="#函数定义-2" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h3><p>从内核空间中读取数据到用户空间。</p>
<h4 id="函数定义-3"><a href="#函数定义-3" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * to：目标地址（用户空间）</span></span><br><span class="line"><span class="comment"> * from：源地址（内核空间）</span></span><br><span class="line"><span class="comment"> * n：将要拷贝数据的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回0，失败返回没有拷贝成功的数据字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h3><p>从用户空间中读取数据到内核空间。</p>
<h4 id="函数定义-4"><a href="#函数定义-4" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * to：目标地址（内核空间）</span></span><br><span class="line"><span class="comment"> * from：源地址（用户空间）</span></span><br><span class="line"><span class="comment"> * n：将要拷贝数据的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回0，失败返回没有拷贝成功的数据字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动设备树和设备匹配问题</title>
    <url>/2024/01/05/Linux%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E5%92%8C%E8%AE%BE%E5%A4%87%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、如何匹配设备？"><a href="#一、如何匹配设备？" class="headerlink" title="一、如何匹配设备？"></a>一、如何匹配设备？</h4><h5 id="1、传统匹配方式ID列表"><a href="#1、传统匹配方式ID列表" class="headerlink" title="1、传统匹配方式ID列表"></a>1、传统匹配方式ID列表</h5><p>这个列表中包含了设备的标识符，例如设备的厂商和型号等。在这里，我们只有一个成员：{“alientek,ap3216c”, 0}。这个字符串 “alientek,ap3216c” 是设备的兼容性字符串，用于识别设备。而0是一个标识符，可以用于在一个驱动程序中区分多个相同类型的设备。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>当驱动加载时，内核会遍历 ap3216c_id[] 中的每个成员。<br>对于每个成员，内核会将其与<strong>已连接的设备</strong>进行比较。<br>如果匹配成功（例如设备的 compatible 属性与列表中的字符串匹配），则使用该标识符与设备进行匹配。<br>匹配成功后，内核会调用 probe 函数并传递匹配成功的 i2c_client 结构体和匹配的标识符。</p>
<h5 id="2、设备树匹配列表"><a href="#2、设备树匹配列表" class="headerlink" title="2、设备树匹配列表"></a>2、设备树匹配列表</h5><p>这个列表用于与设备树中的设备节点匹配。在设备树中，每个设备节点都会包含一个 compatible 属性，用于描述设备的兼容性。在这里，我们也只有一个成员：{ .compatible &#x3D; “alientek,ap3216c” }。这个字符串和传统匹配方式中的一样，用于描述设备的兼容性。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>内核会在设备树中查找所有的设备节点，并查看每个节点的 compatible 属性。<br>对于 ap3216c_of_match[] 中的每个成员，内核会将其与<strong>设备节点</strong>的 compatible 属性进行比较。<br>如果设备树中存在一个节点的 compatible 属性与列表中的字符串匹配，则内核认为找到了匹配的设备。<br>匹配成功后，内核会创建对应的 i2c_client 结构体，并调用 probe 函数并传递该结构体。</p>
<h4 id="二、为什么会同时使用这两种方式？"><a href="#二、为什么会同时使用这两种方式？" class="headerlink" title="二、为什么会同时使用这两种方式？"></a>二、为什么会同时使用这两种方式？</h4><p><strong>兼容性</strong>：使用两种方式可以增加驱动的兼容性，使其可以适应不同的硬件配置和平台。某些设备可能没有设备树信息，但可以使用传统匹配方式，而另一些可能只能通过设备树进行匹配。</p>
<p><strong>平台支持</strong>：在不同的平台上，驱动可能需要适配不同的设备树结构。有些平台可能更倾向于使用设备树匹配方式，而另一些可能更倾向于传统匹配方式。因此，同时使用两种方式可以提高驱动在各种平台上的适应性。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>ap3216c设备驱动开发流程</title>
    <url>/2023/12/27/ap3216c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="一、修改设备树"><a href="#一、修改设备树" class="headerlink" title="一、修改设备树"></a>一、修改设备树</h4><p>在Ubuntu中进入板子内核源码目录，打开dts设备树文件，修改添加i2c设备数相关信息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>定义了一个名为 i2c1 的 I2C 控制器节点，指定了以下属性：</p>
<ol>
<li>clock-frequency：指定 I2C 时钟频率为 100000 Hz。</li>
<li>pinctrl-names：定义了 pinctrl 的名称为 “default”。</li>
<li>pinctrl-0：指定了用于该 I2C 控制器的 pinctrl 配置为 pinctrl_i2c1。</li>
<li>status：设备状态为 “okay”，表示设备正常。</li>
</ol>
<p>在 i2c1 控制器下面，定义了一个名为 ap3216c@1e 的节点，表示连接到 i2c1 控制器的 AP3216C 光传感器。该节点定义了以下属性：</p>
<ol>
<li>compatible：设备兼容性字符串，指定了设备的兼容性为 “alientek,ap3216c”。</li>
<li>reg：设备的 I2C 地址为 &lt;0x1e&gt;。</li>
</ol>
<p>接着编译设备树文件，在内核中直接make，然后通过NFS 协议，将该设备树文件发送给板子，板子接受到后，将该设备树文件替换掉原来的设备树文件，重新启动板子，就实现了设备树的修改。</p>
<h4 id="二、实现驱动程序框架"><a href="#二、实现驱动程序框架" class="headerlink" title="二、实现驱动程序框架"></a>二、实现驱动程序框架</h4><p>包括以下内容：<br><strong>设备结构体</strong>：ap3216c_dev，含有设备号、设备节点等<br><strong>i2c驱动结构体</strong>：i2c_driver ap3216c_driver，含有ap3216c_probe、ap3216c_remove、ap3216c_of_match、ap3216c_id<br><strong>ap3216c操作结构体</strong>：struct file_operations ap3216c_ops，包含open、release、read<br><strong>ap3216c_probe</strong>：i2c驱动的probe函数，当驱动与设备匹配以后此函数就会执行，包含构建设备号、注册设备、创建类、创建设备</p>
<h4 id="三、实现ap3216c相关函数"><a href="#三、实现ap3216c相关函数" class="headerlink" title="三、实现ap3216c相关函数"></a>三、实现ap3216c相关函数</h4><p><strong>ap3216c_read_regs</strong>：用于读取多个寄存器，按照手册上i2c时序来实现<br><strong>ap3216c_write_regs</strong>：用于对多个寄存器写入数据，按照手册上i2c时序来实现<br><strong>ap3216c_readdata</strong>：用于读取ap3216c相关数据，通过查手册，按照手册上的寄存器读取方式来实现(两个寄存器控制一个参数，光照是16位，距离是8位)</p>
<h4 id="四、实现makefile"><a href="#四、实现makefile" class="headerlink" title="四、实现makefile"></a>四、实现makefile</h4><p>执行 make 命令时，会调用 kernel_modules 目标，进而执行内核的 Makefile 中的 make modules 命令来编译内核模块。执行 make clean 命令会清理编译生成的文件。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>icm20608设备驱动开发流程</title>
    <url>/2024/01/01/icm20608%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="SPI-设备驱动编写流程"><a href="#SPI-设备驱动编写流程" class="headerlink" title="SPI 设备驱动编写流程"></a>SPI 设备驱动编写流程</h3><h4 id="一、-IO-的-pinctrl-子节点创建与修改"><a href="#一、-IO-的-pinctrl-子节点创建与修改" class="headerlink" title="一、 IO 的 pinctrl 子节点创建与修改"></a>一、 IO 的 pinctrl 子节点创建与修改</h4><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！</p>
<h4 id="二、SPI-设备节点的创建与修改"><a href="#二、SPI-设备节点的创建与修改" class="headerlink" title="二、SPI 设备节点的创建与修改"></a>二、SPI 设备节点的创建与修改</h4><h5 id="1、添加-ICM20608-所使用的-IO"><a href="#1、添加-ICM20608-所使用的-IO" class="headerlink" title="1、添加 ICM20608 所使用的 IO"></a>1、添加 ICM20608 所使用的 IO</h5><p>和I2C类似，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="number">0x10b0</span> <span class="comment">/* CS */</span></span><br><span class="line">MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="number">0x10b1</span> <span class="comment">/* SCLK */</span></span><br><span class="line">MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="number">0x10b1</span> <span class="comment">/* MISO */</span></span><br><span class="line">MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="number">0x10b1</span> <span class="comment">/* MOSI */</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="2、在-ecspi3-节点追加-icm20608-子节点"><a href="#2、在-ecspi3-节点追加-icm20608-子节点" class="headerlink" title="2、在 ecspi3 节点追加 icm20608 子节点"></a>2、在 ecspi3 节点追加 icm20608 子节点</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">spidev: icm20608@<span class="number">0</span> &#123;</span><br><span class="line">    compatible = <span class="string">&quot;alientek,icm20608&quot;</span>;</span><br><span class="line">    spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;</span><br><span class="line">    reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="三、头文件"><a href="#三、头文件" class="headerlink" title="三、头文件"></a>三、头文件</h4><p>根据手册寄存器相关信息，定义一些ICM20608寄存器地址</p>
<h4 id="四、调用Linux种SPI驱动API"><a href="#四、调用Linux种SPI驱动API" class="headerlink" title="四、调用Linux种SPI驱动API"></a>四、调用Linux种SPI驱动API</h4><p>构建spi_transfer，然后将其打包到spi_message里面，需要使用spi_init初始化spi_message，然后使用spi_message_add_tail将spi_transfer添加到spi_message中，最终使用spi_sync（同步）或spi_async（异步）来发送。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *tx_buf;  <span class="comment">//保存着要发送的数据</span></span><br><span class="line">    <span class="type">void</span> *rx_buf;        <span class="comment">//用于保存接收到的数据。</span></span><br><span class="line">    <span class="type">unsigned</span> len;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>




<h4 id="五、static-int-icm20608-read-regs函数实现"><a href="#五、static-int-icm20608-read-regs函数实现" class="headerlink" title="五、static int icm20608_read_regs函数实现"></a>五、static int icm20608_read_regs函数实现</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> txdata[len];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_message</span> m;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_transfer</span> *t;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_device</span> *spi = (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//片选拉低</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建spi_transfer</span></span><br><span class="line">	t = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步：发送要读取的寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：读取数据</span></span><br><span class="line">    txdata[<span class="number">0</span>] = <span class="number">0xff</span>;</span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 另一种方式替代67-90，通过内核提供的函数  */</span></span><br><span class="line">    data = reg | <span class="number">0x80</span>;</span><br><span class="line">    <span class="built_in">spi_write</span>(spi, &amp;data, <span class="number">1</span>);  <span class="comment">//发送要读取的寄存器地址</span></span><br><span class="line">    <span class="built_in">spi_read</span>(spi, buf, len);   <span class="comment">//读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//片选拉高</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h4 id="六、static-s32-icm20608-write-regs函数实现"><a href="#六、static-s32-icm20608-write-regs函数实现" class="headerlink" title="六、static s32 icm20608_write_regs函数实现"></a>六、static s32 icm20608_write_regs函数实现</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> txdata[len];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_message</span> m;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_transfer</span> *t;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_device</span> *spi = (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//片选拉低</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建spi_transfer</span></span><br><span class="line">	t = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步：发送要写的寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg &amp; ~<span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：读取数据</span></span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 另一种方式，通过内核提供的函数  */</span></span><br><span class="line">    data = reg | ~<span class="number">0x80</span>;</span><br><span class="line">    <span class="built_in">spi_write</span>(spi, &amp;data, <span class="number">1</span>);  <span class="comment">//发送要写的寄存器地址</span></span><br><span class="line">    <span class="built_in">spi_write</span>(spi, buf, len);   <span class="comment">//写数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//片选拉高</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>zr的第一篇博客文章</title>
    <url>/2023/12/14/zr%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>zr os!</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理系统</title>
    <url>/2024/01/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、开启分页机制"><a href="#一、开启分页机制" class="headerlink" title="一、开启分页机制"></a>一、开启分页机制</h3><h4 id="1、准备好页目录及页表"><a href="#1、准备好页目录及页表" class="headerlink" title="1、准备好页目录及页表"></a>1、准备好页目录及页表</h4><ol>
<li>清空页目录：首先清空了页目录占用的空间，将每个字节都设置为0，确保页目录表是空的。</li>
<li>创建页目录项（PDE）：<br>  a. 将低1GB的虚拟地址空间映射到物理地址空间，方便用户进程和内核的访问。<br>  b. 创建了一个PDE来表示这个映射，将这个PDE写入到页目录表的第0个和倒数第二个目录项中。<br>  c. 最后一个PDE被设置为指向页目录表自身的地址，形成了页目录表的循环结构，以便操作系统可以通过虚拟地址访问页目录表。</li>
<li>创建页目录表（PTE）：<br>  a. 填充了第一个页表。这个页表将虚拟地址的低1GB映射到物理地址的低1GB，这样用户空间的进程可以访问到这部分物理地址空间。<br>  b. 创建了内核其他页表的PDE，将这些页表映射到页目录表的后续项中，从而映射了内核的其他地址空间。</li>
</ol>
<h4 id="2、重启加载-GDT"><a href="#2、重启加载-GDT" class="headerlink" title="2、重启加载 GDT"></a>2、重启加载 GDT</h4><p>重启加载 GDT 的主要目的是为了确保在分页机制启用后，GDT 中的段描述符已经正确地反映了新的内存布局和内核的位置。这是因为分页机制的启用会导致内存的地址映射发生变化，原来的地址和段基址可能已经不再有效。因此，需要更新 GDT 中的段描述符，以正确地映射内核和其他重要的段。</p>
<h4 id="3、启用分页机制"><a href="#3、启用分页机制" class="headerlink" title="3、启用分页机制"></a>3、启用分页机制</h4><p>将页目录表的物理地址赋给 cr3 寄存器，开启 cr0 寄存器的 pg 位，重新加载 GDT</p>
<h3 id="二、实现字符串函数"><a href="#二、实现字符串函数" class="headerlink" title="二、实现字符串函数"></a>二、实现字符串函数</h3><h4 id="1、memset-用于将一段内存区域的内容全部设置为指定的值。"><a href="#1、memset-用于将一段内存区域的内容全部设置为指定的值。" class="headerlink" title="1、memset 用于将一段内存区域的内容全部设置为指定的值。"></a>1、memset 用于将一段内存区域的内容全部设置为指定的值。</h4><h4 id="2、memcpy-用于将源内存区域的内容复制到目标内存区域。"><a href="#2、memcpy-用于将源内存区域的内容复制到目标内存区域。" class="headerlink" title="2、memcpy 用于将源内存区域的内容复制到目标内存区域。"></a>2、memcpy 用于将源内存区域的内容复制到目标内存区域。</h4><h4 id="3、memcmp-用于比较两个内存区域的内容是否相等。"><a href="#3、memcmp-用于比较两个内存区域的内容是否相等。" class="headerlink" title="3、memcmp 用于比较两个内存区域的内容是否相等。"></a>3、memcmp 用于比较两个内存区域的内容是否相等。</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将 dst_起始的 size 个字节置为 value */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">uint8_t</span> value, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = (<span class="type">uint8_t</span>*)dst_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">    *dst++ = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 src_起始的 size 个字节复制到 dst_ */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">const</span> <span class="type">void</span>* src_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span> &amp;&amp; src_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = dst_;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* src = src_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">    *dst++ = *src++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连续比较以地址 a_和地址 b_开头的 size 个字节，若相等则返回 0，</span></span><br><span class="line"><span class="comment">若 a_大于 b_，返回+1，否则返回−1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* a = a_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* b = b_;</span><br><span class="line">    ASSERT(a != <span class="literal">NULL</span> || b != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*a != *b) &#123;</span><br><span class="line">            <span class="keyword">return</span> *a &gt; *b ? <span class="number">1</span> : −<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="三、实现位图bitmap的相关接口函数"><a href="#三、实现位图bitmap的相关接口函数" class="headerlink" title="三、实现位图bitmap的相关接口函数"></a>三、实现位图bitmap的相关接口函数</h3><h4 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h4><p>位图相当于一组资源的映射。位图中的每一位和被管理的单位资源都是一对一的关系，故位图主要用于管理容量较大的资源。</p>
<h4 id="2、bitmap-init-struct-bitmap-btmp"><a href="#2、bitmap-init-struct-bitmap-btmp" class="headerlink" title="2、bitmap_init(struct bitmap* btmp)"></a>2、bitmap_init(struct bitmap* btmp)</h4><p>函数用于初始化位图，将位图中所有位都置为 0。<br>使用 memset 函数将位图内存块的所有内容都初始化为 0。</p>
<h4 id="3、bitmap-scan-test-struct-bitmap-btmp-uint32-t-bit-idx"><a href="#3、bitmap-scan-test-struct-bitmap-btmp-uint32-t-bit-idx" class="headerlink" title="3、bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx)"></a>3、bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx)</h4><p>函数用于判断位图中某一位的状态。<br>首先根据 bit_idx 计算出位所在的字节索引 byte_idx 和位索引 bit_odd。<br>使用位操作，将对应位的状态取出并返回。</p>
<h4 id="4、bitmap-scan-struct-bitmap-btmp-uint32-t-cnt"><a href="#4、bitmap-scan-struct-bitmap-btmp-uint32-t-cnt" class="headerlink" title="4、bitmap_scan(struct bitmap* btmp, uint32_t cnt)"></a>4、bitmap_scan(struct bitmap* btmp, uint32_t cnt)</h4><p>函数用于设置位图中某一位的状态。</p>
<ol>
<li>逐字节比较找到第一个非满字节</li>
<li>查找连续的空闲位</li>
<li>返回空闲位的起始下标<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line">    <span class="comment">/* 先逐字节比较，蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len)) &#123;</span><br><span class="line">        <span class="comment">/* 1 表示该位已分配，若为 0xff，则表示该字节内已无空闲位，向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len) &#123; <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对，返回空闲位的索引。 */</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和 btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte]) &#123;</span><br><span class="line">        idx_bit++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit; <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start); <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>; <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>; <span class="comment">// 先将其置为 -1，若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit))) &#123; <span class="comment">// 若 next_bit 为 0</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt) &#123; <span class="comment">// 若找到连续的 cnt 个空位</span></span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="四、实现内存管理系统"><a href="#四、实现内存管理系统" class="headerlink" title="四、实现内存管理系统"></a>四、实现内存管理系统</h3><h3 id="1、vaddr-get："><a href="#1、vaddr-get：" class="headerlink" title="1、vaddr_get："></a>1、vaddr_get：</h3><p>这个函数用于从虚拟地址管理池中获取一定数量的虚拟地址空间。<br>根据传入的内存池类型和页面数量，调用 bitmap_scan 和 bitmap_set 来管理虚拟地址的分配情况。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">        <span class="comment">// 在 kernel_vaddr 的虚拟地址位图中找到一段连续的虚拟地址</span></span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置这段虚拟地址已被占用</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + (cnt++), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算起始虚拟地址</span></span><br><span class="line">        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对用户内存池的处理，这部分没有具体实现，根据需要补充</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、palloc"><a href="#2、palloc" class="headerlink" title="2、palloc"></a>2、palloc</h4><p>这个函数用于从指定的内存池中分配一页的物理内存。<br>通过调用 bitmap_scan 和 bitmap_set 来管理物理页的分配情况。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置这个位已被占用</span></span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="3、page-table-add"><a href="#3、page-table-add" class="headerlink" title="3、page_table_add"></a>3、page_table_add</h4><p>这个函数用于将虚拟地址和物理地址的映射添加到页表中。<br>根据传入的虚拟地址，计算出页表和页目录项的指针，然后将物理地址和相关标志写入页表中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)_vaddr, page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">    <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据虚拟地址计算出对应的页表项（PTE）和页目录项（PDE）。</span></span><br><span class="line"><span class="comment">   如果页目录项存在（已经分配），则直接将物理地址填入对应的页表项。</span></span><br><span class="line"><span class="comment">   如果页目录项不存在（未分配），则先分配一个页目录项，然后将对应的页表项清零，并填入物理地址。 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;</span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>))</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            PANIC(<span class="string">&quot;pte repeat&quot;</span>);</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line">        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4、malloc-page"><a href="#4、malloc-page" class="headerlink" title="4、malloc_page"></a>4、malloc_page</h4><p>这个函数是在内核中用于分配连续多页的虚拟地址和物理内存的函数。并且建立虚拟地址和物理地址之间的映射关系，从而为进程提供可用的内存空间。<br>在实现中调用了 vaddr_get 和 palloc，并在分配页面后调用 page_table_add 来建立映射关系。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">        vaddr += PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理系统的异常处理</title>
    <url>/2024/03/01/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="位图保存时机："><a href="#位图保存时机：" class="headerlink" title="位图保存时机："></a>位图保存时机：</h3><ol>
<li>位图保存的时机通常取决于系统的需求和性能要求。一般来说，位图的保存应该在内存分配或释放操作之后立即进行。这样可以确保位图的状态与实际内存的状态保持同步，并且在系统异常或掉电等情况下可以快速恢复。</li>
<li>另外，可以在位图发生较大变化时进行定期保存，以减少保存操作的频率，提高系统性能。</li>
</ol>
<h3 id="系统宕机处理："><a href="#系统宕机处理：" class="headerlink" title="系统宕机处理："></a>系统宕机处理：</h3><ol>
<li>当系统遇到宕机或异常情况时，位图的保存状态可能会受到影响。为了防止数据丢失或损坏，可以在系统启动时检查位图的一致性，并尝试恢复到上一次保存的状态。</li>
<li>在系统设计阶段，可以采用类似于事务处理的机制，确保位图和实际内存分配状态的一致性，从而减少系统宕机时的影响。</li>
</ol>
<h3 id="内存管理对整片内存擦除次数的保护机制："><a href="#内存管理对整片内存擦除次数的保护机制：" class="headerlink" title="内存管理对整片内存擦除次数的保护机制："></a>内存管理对整片内存擦除次数的保护机制：</h3><p>在嵌入式系统中，内存的擦除次数是需要注意的问题，特别是对于闪存等具有有限擦写寿命的存储介质。为了保护整片内存的擦除次数，可以采取以下措施：</p>
<ol>
<li>实现 wear leveling（磨损平衡）技术，通过均衡地分配擦写操作，延长存储介质的使用寿命。</li>
<li>实施垃圾回收机制，定期清理不再使用的内存块，减少擦写次数。</li>
<li>使用 ECC（错误校正码）或其他数据完整性校验技术，确保数据的可靠性，减少由于擦写错误引起的数据损坏。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式中常用C程序</title>
    <url>/2024/02/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E5%B8%B8%E7%94%A8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1、十六进制字符转整型数字"><a href="#1、十六进制字符转整型数字" class="headerlink" title="1、十六进制字符转整型数字"></a>1、十六进制字符转整型数字</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">功能：将16进制的字符串转换为10进制的数字</span></span><br><span class="line"><span class="comment">常用的函数有atoi,atol,他们都是将10进制的数字字符串转换为int或是long类型，所以在有些情况下不适用。</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//该函数用于将单个十六进制的字符转为10进制数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c2i</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果是数字，则用数字的ASCII码减去48, 如果ch = &#x27;2&#x27; ,则 &#x27;2&#x27; - 48 = 2  </span></span><br><span class="line">    <span class="comment">// isdigit(ch)用于判断字符 ch 是否是一个数字字符的函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))  </span><br><span class="line">       <span class="keyword">return</span> ch - <span class="number">48</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果是字母，但不是A~F,a~f则返回  </span></span><br><span class="line">    <span class="keyword">if</span>( ch &lt; <span class="string">&#x27;A&#x27;</span> || (ch &gt; <span class="string">&#x27;F&#x27;</span> &amp;&amp; ch &lt; <span class="string">&#x27;a&#x27;</span>) || ch &gt; <span class="string">&#x27;z&#x27;</span> )  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果是大写字母，则用数字的ASCII码减去55, 如果ch = &#x27;A&#x27; ,则 &#x27;A&#x27; - 55 = 10  </span></span><br><span class="line">    <span class="comment">// 如果是小写字母，则用数字的ASCII码减去87, 如果ch = &#x27;a&#x27; ,则 &#x27;a&#x27; - 87 = 10  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))  </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">isupper</span>(ch) ? ch - <span class="number">55</span> : ch - <span class="number">87</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//该函数用于将16进制字符串转为十进制数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    <span class="type">int</span> bits;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">char</span> str[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == hex) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input para error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果输入的字符串以 &quot;0x&quot; 或 &quot;0X&quot; 开头，则去除这个前缀</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="string">&#x27;0&#x27;</span>== hex[<span class="number">0</span>]) &amp;&amp; ((<span class="string">&#x27;X&#x27;</span> == hex[<span class="number">1</span>]) || (<span class="string">&#x27;x&#x27;</span> == hex[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, &amp;hex[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, hex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input num = %s \n&quot;</span>, str);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, temp = <span class="number">0</span>; i &lt; len; i++, temp = <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 调用 c2i 函数将十六进制字符转换为对应的十进制数值</span></span><br><span class="line">        temp = <span class="built_in">c2i</span>( *(str + i) );  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一个十六进制位对应 4 位二进制位，需要左移相应的位数</span></span><br><span class="line">        bits = (len - i - <span class="number">1</span>) * <span class="number">4</span>;  </span><br><span class="line">        temp = temp &lt;&lt; bits;  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用按位或操作将每个字节的值合并到最终结果中</span></span><br><span class="line">        num = num | temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2、字符串转整型"><a href="#2、字符串转整型" class="headerlink" title="2、字符串转整型"></a>2、字符串转整型</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">功能：将正常输入的16进制或是10进制的字符串转换为int数据类型。</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">String2int</span><span class="params">(<span class="type">char</span> *strChar)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pstrCmp1 = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pstrCmp2 = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> uiValue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == strChar)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符串的长度，并且在长度小于等于 0 的情况下返回 -1。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= (len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)strChar)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strstr是查找子字符串的函数调用，判断字符串是否以 &quot;0x&quot; 或 &quot;0X&quot; 开头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != (pstr = <span class="built_in">strstr</span>(strChar, <span class="string">&quot;0x&quot;</span>)) || <span class="literal">NULL</span> != (pstr = <span class="built_in">strstr</span>(strChar, <span class="string">&quot;0X&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 将指针 pstr 移动到真正的十六进制数的起始位置（去掉 &quot;0x&quot; 或 &quot;0X&quot;）</span></span><br><span class="line">        pstr = (<span class="type">char</span> *)strChar + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt;= (len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstr)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = (len - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pstr[i] &gt; <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果字符大于 &#x27;F&#x27;，说明是小写十六进制字符，会在 pstrCmp2 中查找对应字符的位置 t，然后将对应的值左移 j 位（每个十六进制数需要占据 4 位），并将这个值按位或（|）到 uiValue 中。</span></span><br><span class="line">                <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstrCmp2); t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pstrCmp2[t] == pstr[i])</span><br><span class="line">                        uiValue |= (t &lt;&lt; (j++ * <span class="number">4</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果字符不大于 &#x27;F&#x27;，说明是大写十六进制字符，会在 pstrCmp1 中查找对应字符的位置 t，然后同样左移 j 位并按位或到 uiValue 中。</span></span><br><span class="line">                <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstrCmp1); t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pstrCmp1[t] == pstr[i])</span><br><span class="line">                        uiValue |= (t &lt;&lt; (j++ * <span class="number">4</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 atoi 函数将其转换为整数</span></span><br><span class="line">        uiValue = <span class="built_in">atoi</span>((<span class="type">const</span> <span class="type">char</span> *)strChar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uiValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
</search>
