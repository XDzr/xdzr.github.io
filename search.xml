<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CAN开发流程</title>
    <url>/2024/01/23/CAN%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="修改设备树"><a href="#修改设备树" class="headerlink" title="修改设备树"></a>修改设备树</h3><h4 id="1、FlexCAN1-引脚节点信息"><a href="#1、FlexCAN1-引脚节点信息" class="headerlink" title="1、FlexCAN1 引脚节点信息"></a>1、FlexCAN1 引脚节点信息</h4><p>首先是 CAN1 引脚配置信息：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_flexcan1: flexcan1grp&#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX <span class="number">0x1b020</span></span><br><span class="line">MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX <span class="number">0x1b020</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、FlexCAN1-控制器节点信息"><a href="#2、FlexCAN1-控制器节点信息" class="headerlink" title="2、FlexCAN1 控制器节点信息"></a>2、FlexCAN1 控制器节点信息</h4><p>&amp;flexcan1 {<br>pinctrl-names &#x3D; “default”;<br>pinctrl-0 &#x3D; &lt;&amp;pinctrl_flexcan1&gt;;<br>xceiver-supply &#x3D; &lt;&amp;reg_can_3v3&gt;;<br>status &#x3D; “okay”;<br>};</p>
<h4 id="3、使能-Linux-内核自带的-FlexCAN-驱动"><a href="#3、使能-Linux-内核自带的-FlexCAN-驱动" class="headerlink" title="3、使能 Linux 内核自带的 FlexCAN 驱动"></a>3、使能 Linux 内核自带的 FlexCAN 驱动</h4><ol>
<li>使能 CAN 总线:首先打开 CAN 总线子系统，在 Linux 下 CAN 总线是作为网络子系统的，打开CAN bus subsystem support</li>
<li>使能 Freescale 系 CPU 的 FlexCAN 外设驱动，</li>
</ol>
<h4 id="4、FlexCAN-测试"><a href="#4、FlexCAN-测试" class="headerlink" title="4、FlexCAN 测试"></a>4、FlexCAN 测试</h4><ol>
<li>检查 CAN 网卡设备是否存在：ifconfig -a</li>
<li>移植 iproute2</li>
<li>移植 can-utils 工具</li>
<li>回环测试：在一个板子上进行 CAN 回环测试，自己给自己发送数据并接受</li>
</ol>
<h4 id="5、应用程序"><a href="#5、应用程序" class="headerlink" title="5、应用程序"></a>5、应用程序</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_can_frame</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> can_id, <span class="type">int</span> can_data_len, <span class="type">unsigned</span> <span class="type">char</span>* can_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span>      <span class="comment">//用于存储与CAN设备相关的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span>              <span class="comment">//用于存储获取到的CAN设备的信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ifname = <span class="string">&quot;can0&quot;</span>;   <span class="comment">// CAN 设备名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error while opening socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ioctl() 函数获取CAN设备的接口索引，并将其存储在 ifr.ifr_ifindex 中。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, ifname);</span><br><span class="line">    ioctl(s, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字与 CAN 设备绑定</span></span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line">    <span class="keyword">if</span> (bind(s, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in socket bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备要发送的数据帧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span></span><br><span class="line">    frame.can_id = can_id;    <span class="comment">// CAN ID</span></span><br><span class="line">    frame.can_dlc = can_data_len;  <span class="comment">// 数据长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(frame.data, can_data, can_data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据帧</span></span><br><span class="line">    <span class="type">int</span> nbytes = write(s, &amp;frame, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> can_frame));</span><br><span class="line">    <span class="keyword">if</span> (nbytes != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> can_frame)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in sending CAN frame&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent CAN frame with ID 0x%03X\n&quot;</span>, frame.can_id);</span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN总线难点</title>
    <url>/2024/01/18/CAN%E6%80%BB%E7%BA%BF%E9%9A%BE%E7%82%B9/</url>
    <content><![CDATA[<h3 id="带宽和速率管理："><a href="#带宽和速率管理：" class="headerlink" title="带宽和速率管理："></a>带宽和速率管理：</h3><p>CAN 总线通常用于连接多个节点，这些节点可能会发送大量的数据，<br>因此需要有效地管理带宽和数据传输速率。特别是在高速 CAN 中，<br>如何确保数据在高速传输中的可靠性和实时性是一个挑战。</p>
<ol>
<li>使用错误检测和纠正机制：CAN协议通常使用CRC（循环冗余校验）来检测数据传输中的错误，并且一些应用可能会使用更高级别的纠错码（如重复码或汉明码）来进行错误纠正。</li>
<li>优先级机制：CAN协议支持消息的优先级。通过正确设置消息的优先级，可以确保重要数据优先发送，从而提高实时性。</li>
</ol>
<h3 id="网络管理和拓扑结构："><a href="#网络管理和拓扑结构：" class="headerlink" title="网络管理和拓扑结构："></a>网络管理和拓扑结构：</h3><p>设计一个复杂的 CAN 网络需要考虑节点之间的连接方式、拓扑结构和通信规则等。这涉及到网络拓扑设计、节点分配和通信规则制定等方面的工作。</p>
<h3 id="故障诊断和容错机制："><a href="#故障诊断和容错机制：" class="headerlink" title="故障诊断和容错机制："></a>故障诊断和容错机制：</h3><ol>
<li><p>自动重传机制：CAN总线上的节点在发送消息时，会监视总线上的确认位（ACK）。如果节点没有收到ACK，它将自动重试发送消息，直到收到ACK或者达到最大重试次数。这种机制确保了消息的可靠传输。</p>
</li>
<li><p>错误帧和错误报告：CAN总线上的节点会监视错误帧，这些错误帧会在总线上传输，用于表示数据传输过程中的错误。节点可以根据收到的错误帧来检测总线上的错误，并将错误信息报告给系统的上层。</p>
</li>
<li><p>错误标识符：CAN总线上的每个节点都有一个唯一的标识符（ID），用于识别消息的发送者和接收者。如果节点收到了具有错误标识符的消息，它将忽略该消息，并将错误信息报告给系统的上层。</p>
</li>
</ol>
<h3 id="如何确保你的CAN发送和接收代码正确"><a href="#如何确保你的CAN发送和接收代码正确" class="headerlink" title="如何确保你的CAN发送和接收代码正确"></a>如何确保你的CAN发送和接收代码正确</h3><ol>
<li>硬件连接：确认CAN控制器与CAN总线连接正确，确保电源、地线和信号线连接正确并且稳定。</li>
<li>使用示波器或CAN分析仪：使用示波器或专用的CAN分析仪来监视CAN总线上的信号。你可以验证发送消息的波形是否正确，以及接收消息时是否出现预期的波形。</li>
<li>通过电压表测试两根线之间的电压可以帮助你判断是否有数据发送。在CAN总线中，当节点发送数据时，会在总线上产生电压差，这可以通过测量两根线之间的电压来检测。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Error: Spawn failed解决办法</title>
    <url>/2023/12/17/Error-Spawn-failed%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>在创建的blog文件夹（即最早建的最大的文件夹）中找到_config.yml，把deploy板块中的repository换成ssh地址</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">repository: 此处填ssh地址</span><br></pre></td></tr></table></figure></div>
<p>如果没有添加过密钥，则前往GitHub的个人设置（点击右上角头像旁边的小三角—&gt;settings)，点击SSH and GPG;在本地通过git生成密钥后再复制并添加到ssh keys中即可。</p>
<h3 id="solution-2："><a href="#solution-2：" class="headerlink" title="solution 2："></a>solution 2：</h3><p>还是在blog文件夹下，删除名为.deploy_git的文件夹，在Windows下操作如下(打开cmd管理员模式)：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">F:  (进入某盘)</span><br><span class="line">cd yourblog/  (进入你的博客文件夹)</span><br><span class="line">rd /s .deploy_git  (删除该文件)</span><br></pre></td></tr></table></figure></div>
<p>然后在git命令行中执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure></div>
<p>然后再走一遍流程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下查看内存使用情况方法</title>
    <url>/2024/02/01/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1、atop"><a href="#1、atop" class="headerlink" title="1、atop"></a>1、atop</h3><p>atop命令是一个终端环境的监控命令。它显示的是各种系统资源（CPU, memory, network, I&#x2F;O, kernel）的综合，并且在高负载的情况下进行了彩色标注。<br>$ sudo atop</p>
<h3 id="2、free"><a href="#2、free" class="headerlink" title="2、free"></a>2、free</h3><p>free命令是一个快速查看内存使用情况的方法，它是对 &#x2F;proc&#x2F;meminfo 收集到的信息的一个概述。<br>$ free -h</p>
<h3 id="3、htop"><a href="#3、htop" class="headerlink" title="3、htop"></a>3、htop</h3><p>htop命令显示了每个进程的内存实时使用率。它提供了所有进程的常驻内存大小、程序总内存大小、共享库大小等的报告。列表可以水平及垂直滚动。<br>$ htop</p>
<h3 id="4、ps"><a href="#4、ps" class="headerlink" title="4、ps"></a>4、ps</h3><p>ps命令可以实时的显示各个进程的内存使用情况。Reported memory usage information includes %MEM (percent of physical memory used), VSZ (total amount of virtual memory used), and RSS (total amount of physical memory used)。你可以使用 “–sort”选项对进程进行排序，例如按RSS进行排序：<br>$ ps aux –sort -rss</p>
<h3 id="5、11-top"><a href="#5、11-top" class="headerlink" title="5、11.top"></a>5、11.top</h3><p>top命令提供了实时的运行中的程序的资源使用统计。你可以根据内存的使用和大小来进行排序。<br>$ top</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下驱动和应用之间的联系</title>
    <url>/2024/01/22/Linux%E4%B8%8B%E9%A9%B1%E5%8A%A8%E5%92%8C%E5%BA%94%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="一、在Linux下，驱动程序是如何与应用程序相联系的"><a href="#一、在Linux下，驱动程序是如何与应用程序相联系的" class="headerlink" title="一、在Linux下，驱动程序是如何与应用程序相联系的"></a>一、在Linux下，驱动程序是如何与应用程序相联系的</h2><h3 id="创建设备文件："><a href="#创建设备文件：" class="headerlink" title="创建设备文件："></a>创建设备文件：</h3><p>在驱动程序的 probe 函数中，会调用函数 device_create() 来创建设备文件，该函数会在 &#x2F;dev 目录下创建一个设备文件，使得应用程序可以通过该设备文件与驱动程序进行通信。</p>
<h3 id="打开设备文件："><a href="#打开设备文件：" class="headerlink" title="打开设备文件："></a>打开设备文件：</h3><p>应用程序可以使用系统调用 open() 打开设备文件，获取与之关联的文件描述符。在驱动程序中，当调用 open 函数时，内核会调用驱动程序中的 open 函数，从而进行设备的初始化等操作。</p>
<h3 id="读写设备文件："><a href="#读写设备文件：" class="headerlink" title="读写设备文件："></a>读写设备文件：</h3><p>应用程序可以使用系统调用 read() 和 write() 来读写设备文件。在驱动程序中，当应用程序调用 read() 或 write() 函数时，内核会调用驱动程序中相应的读取或写入函数，从而对设备进行相应的读写操作。</p>
<h3 id="关闭设备文件："><a href="#关闭设备文件：" class="headerlink" title="关闭设备文件："></a>关闭设备文件：</h3><p>应用程序可以使用系统调用 close() 关闭设备文件。在驱动程序中，当应用程序调用 close() 函数时，内核会调用驱动程序中的 release 函数，执行设备的释放操作。</p>
<h2 id="二、为什么I2C和SPI等要分为适配器驱动和设备驱动？"><a href="#二、为什么I2C和SPI等要分为适配器驱动和设备驱动？" class="headerlink" title="二、为什么I2C和SPI等要分为适配器驱动和设备驱动？"></a>二、为什么I2C和SPI等要分为适配器驱动和设备驱动？</h2><h3 id="设备驱动："><a href="#设备驱动：" class="headerlink" title="设备驱动："></a>设备驱动：</h3><ol>
<li>设备驱动是针对具体的I2C、SPI设备编写的，用于控制和管理这些设备。</li>
<li>设备驱动通常由硬件设备的制造商或硬件厂商的工程师编写，因为他们了解设备的规格和特性。</li>
<li>设备驱动负责处理与设备相关的操作，如数据的读写、寄存器的设置等。</li>
</ol>
<h3 id="适配器驱动："><a href="#适配器驱动：" class="headerlink" title="适配器驱动："></a>适配器驱动：</h3><ol>
<li>适配器驱动是针对I2C、SPI等总线控制器的驱动程序，用于管理总线控制器的操作。</li>
<li>适配器驱动通常由Linux内核开发人员或芯片厂商提供，并包含在Linux内核中。</li>
<li>适配器驱动负责与硬件总线控制器进行通信，控制总线的初始化、数据传输等操作。</li>
</ol>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ol>
<li>设备驱动与具体的设备相关联，因此将设备驱动分离出来，便于管理和维护。</li>
<li>适配器驱动管理总线控制器，因此与硬件平台相关联，通常由操作系统或芯片厂商提供，以确保与硬件的兼容性和稳定性。</li>
<li>这种分离的设计使得Linux内核的驱动开发更加灵活，可以针对不同的设备和硬件平台编写对应的驱动程序，并且能够在不同的硬件上实现相同的接口和功能。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核源码的Makefile、Kconfig和.config文件</title>
    <url>/2024/02/11/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84Makefile%E3%80%81Kconfig%E5%92%8C-config%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="一、三者的作用"><a href="#一、三者的作用" class="headerlink" title="一、三者的作用"></a>一、三者的作用</h3><ol>
<li>Makefile：一个文本形式的文件，编译源文件的方法。</li>
<li>Kconfig：一个文本形式的文件，内核的配置菜单。</li>
<li>.config：编译内核所依据的配置。<br>可以理解为：Kconfig是菜单，Makefile是做法，.config就是你点的菜。</li>
</ol>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><h4 id="1、Makefile"><a href="#1、Makefile" class="headerlink" title="1、Makefile"></a>1、Makefile</h4><p>用来定义哪些内容作为模块编译，哪些条件编译等。子目录Makefile被顶层Makefile包含。</p>
<ol>
<li><p>直接编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y      += xxx.o                </span><br></pre></td></tr></table></figure></div>
<p>表示由xxx.c或xxx.s编译得到xxx.o并直接编进内核。</p>
</li>
<li><p>条件编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj -$(CONFIG_HELLO)  += xxx.o   </span><br></pre></td></tr></table></figure></div>
<p>根据.config文件的CONFIG_XXX来决定文件是否编进内核。</p>
</li>
<li><p>模块编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m     +=xxx.o</span><br></pre></td></tr></table></figure></div>
<p>表示xxx作为模块编译，即执行make modules时才会被编译。</p>
</li>
</ol>
<h4 id="2、Kconfig"><a href="#2、Kconfig" class="headerlink" title="2、Kconfig"></a>2、Kconfig</h4><p>每个config菜单项都有类型定义: bool布尔类型、 tristate三态(内建、模块、移除)、string字符串、 hex十六进制、integer整型。<br>作用：决定make menuconfig时展示的菜单项</p>
<h4 id="3、-config"><a href="#3、-config" class="headerlink" title="3、.config"></a>3、.config</h4><p>通过前俩个文件的分析，.config的含义已经很清晰：内核编译参考文件，查看里面内容可以知道哪些驱动被编译进内核。<br>配置内核方式有3种(任选其一)：</p>
<ol>
<li>make menuconfig</li>
<li>make xxx_defconfig</li>
<li>直接修改.config</li>
</ol>
<h3 id="三、举例说明"><a href="#三、举例说明" class="headerlink" title="三、举例说明"></a>三、举例说明</h3><p>写一个简单的入口函数输出hello world的驱动并编译进内核。<br>步骤：</p>
<ol>
<li>在drivers目录下新建hello文件夹，里面实现hello.c、Makefile、Kconfig。</li>
</ol>
<p><strong>hello.c：</strong></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">first_drv_init</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="built_in">printk</span>(<span class="string">&quot;------------------hello world !--------------------&quot;</span>);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">first_drv_exit</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;------------------exit hello world !--------------------&quot;</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">module_init</span>(first_drv_init); </span><br><span class="line"><span class="built_in">module_exit</span>(first_drv_exit); </span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>Makefile：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_HELLO)         += hello.o  </span><br></pre></td></tr></table></figure></div>

<p><strong>Kconfig：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">config HELLO  </span><br><span class="line">   tristate &quot;ZR&quot;  </span><br><span class="line">   help  </span><br><span class="line">    ZR  </span><br></pre></td></tr></table></figure></div>
<p>config HELLO决定名字：CONFIG_HELLO。<br>ZR：决定了在make menuconfig时显示的名字</p>
<ol start="2">
<li>修改上一级（Linux-3.4.2&#x2F;drivers下）的Makefile、Kconfig。</li>
</ol>
<p><strong>Makefile：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-y  += hello/  </span><br></pre></td></tr></table></figure></div>


<p><strong>Kconfig：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">source  &quot;drivers/hello/Kconfig&quot;  </span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>make menuconfig</li>
<li>make uImage再烧写到开发板。</li>
</ol>
<p>查看内核启动Log，显示helloworld，说明hello.c成功编进内核</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>用户通过 Kconfig 进行内核配置，选择需要的功能和选项。</li>
<li>用户的配置选择会被保存到 .config 文件中。</li>
<li>Makefile 会在构建内核时使用 .config 文件中的配置选项，根据用户的配置生成相应的内核映像和模块。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动开发常用函数</title>
    <url>/2024/02/27/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap"></a>ioremap</h3><p>ioremap是Linux内核中的一个函数，用于将物理地址映射到内核的虚拟地址空间，以便内核可以直接访问设备的寄存器或内存区域。它通常用于设备驱动程序中，特别是在需要直接访问设备内存或寄存器时。</p>
<h4 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * offset：要映射的物理地址的偏移量。</span></span><br><span class="line"><span class="comment"> * size：要映射的区域大小。</span></span><br><span class="line"><span class="comment"> * void __iomem *：映射后的虚拟地址，通常是volatile类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> __iomem *<span class="title">ioremap</span><span class="params">(<span class="type">phys_addr_t</span> offset, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pathname ：文件的名称，可以包含（绝对和相对）路径</span></span><br><span class="line"><span class="comment"> * flags：文件打开模式</span></span><br><span class="line"><span class="comment"> * mode: 用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * pathname,<span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></div>


<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p>
<h4 id="函数定义-1"><a href="#函数定义-1" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为* 0, 则read()不会有作用并返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内。</p>
<h4 id="函数定义-2"><a href="#函数定义-2" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> * buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h3><p>从内核空间中读取数据到用户空间。</p>
<h4 id="函数定义-3"><a href="#函数定义-3" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * to：目标地址（用户空间）</span></span><br><span class="line"><span class="comment"> * from：源地址（内核空间）</span></span><br><span class="line"><span class="comment"> * n：将要拷贝数据的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回0，失败返回没有拷贝成功的数据字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h3><p>从用户空间中读取数据到内核空间。</p>
<h4 id="函数定义-4"><a href="#函数定义-4" class="headerlink" title="函数定义"></a>函数定义</h4><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * to：目标地址（内核空间）</span></span><br><span class="line"><span class="comment"> * from：源地址（用户空间）</span></span><br><span class="line"><span class="comment"> * n：将要拷贝数据的字节数</span></span><br><span class="line"><span class="comment"> * 成功返回0，失败返回没有拷贝成功的数据字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动框架（无设备树）</title>
    <url>/2024/04/12/Linux%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%88%E6%97%A0%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<h2 id="四、新字符设备驱动框架"><a href="#四、新字符设备驱动框架" class="headerlink" title="四、新字符设备驱动框架"></a>四、新字符设备驱动框架</h2><p>字符设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备的时候就使用unregister_chrdev 函数注销字符设备，驱动模块加载成功以后还需要手动使用 mknod 命令创建设备节点。 register_chrdev 和 unregister_chrdev 这两个函数是老版本驱动使用的函数，现在新的字符设备驱动已经不再使用这两个函数，而是使用Linux内核推荐的新字符设备驱动API函数。</p>
<h3 id="4-1-新字符设备驱动原理"><a href="#4-1-新字符设备驱动原理" class="headerlink" title="4.1 新字符设备驱动原理"></a>4.1 新字符设备驱动原理</h3><h4 id="4-1-1-分配和释放设备号"><a href="#4-1-1-分配和释放设备号" class="headerlink" title="4.1.1 分配和释放设备号"></a>4.1.1 分配和释放设备号</h4><p>使用 register_chrdev 函数注册字符设备的时候只需要给定一个主设备号即可，但是这样会带来两个问题：</p>
<ol>
<li>需要我们事先确定好哪些主设备号没有使用。</li>
<li>会将一个主设备号下的所有次设备号都使用掉，比如现在设置 LED 这个主设备号为200，那么 0~1048575(2^20-1)这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。</li>
</ol>
<p>解决这两个问题最好的方法就是要使用设备号的时候向 Linux 内核申请，需要几个就申请几个，由 Linux 内核分配设备可以使用的设备号。这个就是我们在 40.3.2 小节讲解的设备号的分配，如果没有指定设备号的话就使用如下函数来申请设备号：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, </span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure></div>
<p>如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure></div>
<p>参数 from 是要申请的起始设备号，也就是给定的设备号；参数 count 是要申请的数量，一般都是一个；参数 name 是设备名字。<br>注 销 字 符 设 备 之 后 要 释 放 掉 设 备 号 ， 不 管 是 通 过 alloc_chrdev_region 函 数 还 是register_chrdev_region 函数申请的设备号，统一使用如下释放函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure></div>
<p>新字符设备驱动下，设备号分配示例代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (major) &#123; <span class="comment">/* 定义了主设备号 */</span></span><br><span class="line">    devid = MKDEV(major, <span class="number">0</span>); <span class="comment">/* 大部分驱动次设备号都选择 0*/</span></span><br><span class="line">    register_chrdev_region(devid, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">    alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">/* 申请设备号 */</span></span><br><span class="line">    major = MAJOR(devid); <span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">    minor = MINOR(devid); <span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="4-1-2-新的字符设备注册方法"><a href="#4-1-2-新的字符设备注册方法" class="headerlink" title="4.1.2 新的字符设备注册方法"></a>4.1.2 新的字符设备注册方法</h4><p>1、字符设备结构<br>在 Linux 中使用 cdev 结构体表示一个字符设备， cdev 结构体在 include&#x2F;linux&#x2F;cdev.h 文件中的定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在 cdev 中有两个重要的成员变量： ops 和 dev，这两个就是字符设备文件操作函数集合file_operations 以及设备号 dev_t。编写字符设备驱动之前需要定义一个 cdev 结构体变量，这个变量就表示一个字符设备，如下所示：struct cdev test_cdev;</p>
<p>2、 cdev_init 函数<br>定义好 cdev 变量以后就要使用 cdev_init 函数对其进行初始化， cdev_init 函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br></pre></td></tr></table></figure></div>
<p>参数 cdev 就是要初始化的 cdev 结构体变量，参数 fops 就是字符设备文件操作函数集合。</p>
<p>3、 cdev_add 函数<br>cdev_add 函数用于向 Linux 系统添加字符设备(cdev 结构体变量)，首先使用 cdev_init 函数完成对 cdev 结构体变量的初始化，然后使用 cdev_add 函数向 Linux 系统添加这个字符设备。cdev_add 函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure></div>
<p>参数 p 指向要添加的字符设备(cdev 结构体变量)，参数 dev 就是设备所使用的设备号，参数 count 是要添加的设备数量。以下是完整代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">testcdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    <span class="comment">/* 其他具体的初始项 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">testcdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;testcdev, &amp;test_fops); <span class="comment">/* 初始化 cdev 结构体变量 */</span></span><br><span class="line">cdev_add(&amp;testcdev, devid, <span class="number">1</span>); <span class="comment">/* 添加字符设备 */</span></span><br></pre></td></tr></table></figure></div>


<h3 id="4-2-自动创建设备节点"><a href="#4-2-自动创建设备节点" class="headerlink" title="4.2 自动创建设备节点"></a>4.2 自动创建设备节点</h3><p>当我们使用 modprobe 加载驱动程序以后还需要使用命令“mknod”手动创建设备节点。在驱动中实现自动创建设备节点的功能以后，使用 modprobe 加载驱动模块成功的话就会自动在&#x2F;dev 目录下创建对应的设备文件。</p>
<h4 id="4-2-1-mdev-机制"><a href="#4-2-1-mdev-机制" class="headerlink" title="4.2.1 mdev 机制"></a>4.2.1 mdev 机制</h4><p>udev 是一个用户程序，在 Linux 下通过 udev 来实现设备文件的创建与删除， udev 可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用modprobe 命令成功加载驱动模块以后就自动在&#x2F;dev 目录下创建对应的设备节点文件,使用rmmod 命令卸载驱动模块以后就删除掉&#x2F;dev 目录下的设备节点文件。 使用 busybox 构建根文件系统的时候， busybox 会创建一个 udev 的简化版本—mdev，所以在嵌入式 Linux 中我们使用mdev 来实现设备节点文件的自动创建与删除， Linux 系统中的热插拔事件也由 mdev 管理，在&#x2F;etc&#x2F;init.d&#x2F;rcS 文件中如下语句：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br></pre></td></tr></table></figure></div>
<p>上述命令设置热插拔事件由 mdev 来管理，关于 udev 或 mdev 更加详细的工作原理这里就不详细探讨了，我们重点来学习一下如何通过 mdev 来实现设备文件节点的自动创建与删除。</p>
<h4 id="4-2-2-创建和删除类"><a href="#4-2-2-创建和删除类" class="headerlink" title="4.2.2 创建和删除类"></a>4.2.2 创建和删除类</h4><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类， class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。 class_create 是类创建函数， class_create 是个宏定义，将宏 class_create 展开以后内容如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class *<span class="title function_">class_create</span> <span class="params">(<span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure></div>
<p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。返回值是个指向结构体 class 的指针，也就是创建的类。<br>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;</span><br></pre></td></tr></table></figure></div>
<p>参数 cls 就是要删除的类</p>
<h4 id="4-2-3-创建设备"><a href="#4-2-3-创建设备" class="headerlink" title="4.2.3 创建设备"></a>4.2.3 创建设备</h4><p>创建好类以后还不能实现自动创建设备节点，我们还需要在这个类下创建一个设备。使用 device_create 函数在类下面创建设备， device_create 函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *class,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">                             <span class="type">dev_t</span> devt,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br></pre></td></tr></table></figure></div>
<p>device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。返回值就是创建好的设备。<br>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="type">dev_t</span> devt)</span></span><br></pre></td></tr></table></figure></div>
<p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p>
<h4 id="4-2-4-参考示例"><a href="#4-2-4-参考示例" class="headerlink" title="4.2.4 参考示例"></a>4.2.4 参考示例</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> <span class="comment">/* cdev */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line">    <span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line">    <span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span> <span class="title">testdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* open 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;testdev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="comment">/* 创建设备 */</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 删除设备 */</span></span><br><span class="line">    device_destroy(class, devid);</span><br><span class="line">    <span class="comment">/* 删除类 */</span></span><br><span class="line">    class_destroy(class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br></pre></td></tr></table></figure></div>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux驱动设备树和设备匹配问题</title>
    <url>/2024/01/05/Linux%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E5%92%8C%E8%AE%BE%E5%A4%87%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、如何匹配设备？"><a href="#一、如何匹配设备？" class="headerlink" title="一、如何匹配设备？"></a>一、如何匹配设备？</h4><h5 id="1、传统匹配方式ID列表"><a href="#1、传统匹配方式ID列表" class="headerlink" title="1、传统匹配方式ID列表"></a>1、传统匹配方式ID列表</h5><p>这个列表中包含了设备的标识符，例如设备的厂商和型号等。在这里，我们只有一个成员：{“alientek,ap3216c”, 0}。这个字符串 “alientek,ap3216c” 是设备的兼容性字符串，用于识别设备。而0是一个标识符，可以用于在一个驱动程序中区分多个相同类型的设备。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>当驱动加载时，内核会遍历 ap3216c_id[] 中的每个成员。<br>对于每个成员，内核会将其与<strong>已连接的设备</strong>进行比较。<br>如果匹配成功（例如设备的 compatible 属性与列表中的字符串匹配），则使用该标识符与设备进行匹配。<br>匹配成功后，内核会调用 probe 函数并传递匹配成功的 i2c_client 结构体和匹配的标识符。</p>
<h5 id="2、设备树匹配列表"><a href="#2、设备树匹配列表" class="headerlink" title="2、设备树匹配列表"></a>2、设备树匹配列表</h5><p>这个列表用于与设备树中的设备节点匹配。在设备树中，每个设备节点都会包含一个 compatible 属性，用于描述设备的兼容性。在这里，我们也只有一个成员：{ .compatible &#x3D; “alientek,ap3216c” }。这个字符串和传统匹配方式中的一样，用于描述设备的兼容性。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>内核会在设备树中查找所有的设备节点，并查看每个节点的 compatible 属性。<br>对于 ap3216c_of_match[] 中的每个成员，内核会将其与<strong>设备节点</strong>的 compatible 属性进行比较。<br>如果设备树中存在一个节点的 compatible 属性与列表中的字符串匹配，则内核认为找到了匹配的设备。<br>匹配成功后，内核会创建对应的 i2c_client 结构体，并调用 probe 函数并传递该结构体。</p>
<h4 id="二、为什么会同时使用这两种方式？"><a href="#二、为什么会同时使用这两种方式？" class="headerlink" title="二、为什么会同时使用这两种方式？"></a>二、为什么会同时使用这两种方式？</h4><p><strong>兼容性</strong>：使用两种方式可以增加驱动的兼容性，使其可以适应不同的硬件配置和平台。某些设备可能没有设备树信息，但可以使用传统匹配方式，而另一些可能只能通过设备树进行匹配。</p>
<p><strong>平台支持</strong>：在不同的平台上，驱动可能需要适配不同的设备树结构。有些平台可能更倾向于使用设备树匹配方式，而另一些可能更倾向于传统匹配方式。因此，同时使用两种方式可以提高驱动在各种平台上的适应性。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>ap3216c设备驱动开发流程</title>
    <url>/2023/12/27/ap3216c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="一、修改设备树"><a href="#一、修改设备树" class="headerlink" title="一、修改设备树"></a>一、修改设备树</h4><p>在Ubuntu中进入板子内核源码目录，打开dts设备树文件，修改添加i2c设备数相关信息。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>定义了一个名为 i2c1 的 I2C 控制器节点，指定了以下属性：</p>
<ol>
<li>clock-frequency：指定 I2C 时钟频率为 100000 Hz。</li>
<li>pinctrl-names：定义了 pinctrl 的名称为 “default”。</li>
<li>pinctrl-0：指定了用于该 I2C 控制器的 pinctrl 配置为 pinctrl_i2c1。</li>
<li>status：设备状态为 “okay”，表示设备正常。</li>
</ol>
<p>在 i2c1 控制器下面，定义了一个名为 ap3216c@1e 的节点，表示连接到 i2c1 控制器的 AP3216C 光传感器。该节点定义了以下属性：</p>
<ol>
<li>compatible：设备兼容性字符串，指定了设备的兼容性为 “alientek,ap3216c”。</li>
<li>reg：设备的 I2C 地址为 &lt;0x1e&gt;。</li>
</ol>
<p>接着编译设备树文件，在内核中直接make，然后通过NFS 协议，将该设备树文件发送给板子，板子接受到后，将该设备树文件替换掉原来的设备树文件，重新启动板子，就实现了设备树的修改。</p>
<h4 id="二、实现驱动程序框架"><a href="#二、实现驱动程序框架" class="headerlink" title="二、实现驱动程序框架"></a>二、实现驱动程序框架</h4><p>包括以下内容：<br><strong>设备结构体</strong>：ap3216c_dev，含有设备号、设备节点等<br><strong>i2c驱动结构体</strong>：i2c_driver ap3216c_driver，含有ap3216c_probe、ap3216c_remove、ap3216c_of_match、ap3216c_id<br><strong>ap3216c操作结构体</strong>：struct file_operations ap3216c_ops，包含open、release、read<br><strong>ap3216c_probe</strong>：i2c驱动的probe函数，当驱动与设备匹配以后此函数就会执行，包含构建设备号、注册设备、创建类、创建设备</p>
<h4 id="三、实现ap3216c相关函数"><a href="#三、实现ap3216c相关函数" class="headerlink" title="三、实现ap3216c相关函数"></a>三、实现ap3216c相关函数</h4><p><strong>ap3216c_read_regs</strong>：用于读取多个寄存器，按照手册上i2c时序来实现<br><strong>ap3216c_write_regs</strong>：用于对多个寄存器写入数据，按照手册上i2c时序来实现<br><strong>ap3216c_readdata</strong>：用于读取ap3216c相关数据，通过查手册，按照手册上的寄存器读取方式来实现(两个寄存器控制一个参数，光照是16位，距离是8位)</p>
<h4 id="四、实现makefile"><a href="#四、实现makefile" class="headerlink" title="四、实现makefile"></a>四、实现makefile</h4><p>执行 make 命令时，会调用 kernel_modules 目标，进而执行内核的 Makefile 中的 make modules 命令来编译内核模块。执行 make clean 命令会清理编译生成的文件。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>icm20608设备驱动开发流程</title>
    <url>/2024/01/01/icm20608%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="SPI-设备驱动编写流程"><a href="#SPI-设备驱动编写流程" class="headerlink" title="SPI 设备驱动编写流程"></a>SPI 设备驱动编写流程</h3><h4 id="一、-IO-的-pinctrl-子节点创建与修改"><a href="#一、-IO-的-pinctrl-子节点创建与修改" class="headerlink" title="一、 IO 的 pinctrl 子节点创建与修改"></a>一、 IO 的 pinctrl 子节点创建与修改</h4><p>首先肯定是根据所使用的 IO 来创建或修改 pinctrl 子节点，要注意的就是检查相应的 IO 有没有被其他的设备所使用，如果有的话需要将其删除掉！</p>
<h4 id="二、SPI-设备节点的创建与修改"><a href="#二、SPI-设备节点的创建与修改" class="headerlink" title="二、SPI 设备节点的创建与修改"></a>二、SPI 设备节点的创建与修改</h4><h5 id="1、添加-ICM20608-所使用的-IO"><a href="#1、添加-ICM20608-所使用的-IO" class="headerlink" title="1、添加 ICM20608 所使用的 IO"></a>1、添加 ICM20608 所使用的 IO</h5><p>和I2C类似，在 iomuxc 节点中添加一个新的子节点来描述 ICM20608 所使用的 SPI 引脚，子节点名字为 pinctrl_ecspi3。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="number">0x10b0</span> <span class="comment">/* CS */</span></span><br><span class="line">MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="number">0x10b1</span> <span class="comment">/* SCLK */</span></span><br><span class="line">MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="number">0x10b1</span> <span class="comment">/* MISO */</span></span><br><span class="line">MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="number">0x10b1</span> <span class="comment">/* MOSI */</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h5 id="2、在-ecspi3-节点追加-icm20608-子节点"><a href="#2、在-ecspi3-节点追加-icm20608-子节点" class="headerlink" title="2、在 ecspi3 节点追加 icm20608 子节点"></a>2、在 ecspi3 节点追加 icm20608 子节点</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">spidev: icm20608@<span class="number">0</span> &#123;</span><br><span class="line">    compatible = <span class="string">&quot;alientek,icm20608&quot;</span>;</span><br><span class="line">    spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;</span><br><span class="line">    reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="三、头文件"><a href="#三、头文件" class="headerlink" title="三、头文件"></a>三、头文件</h4><p>根据手册寄存器相关信息，定义一些ICM20608寄存器地址</p>
<h4 id="四、调用Linux种SPI驱动API"><a href="#四、调用Linux种SPI驱动API" class="headerlink" title="四、调用Linux种SPI驱动API"></a>四、调用Linux种SPI驱动API</h4><p>构建spi_transfer，然后将其打包到spi_message里面，需要使用spi_init初始化spi_message，然后使用spi_message_add_tail将spi_transfer添加到spi_message中，最终使用spi_sync（同步）或spi_async（异步）来发送。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *tx_buf;  <span class="comment">//保存着要发送的数据</span></span><br><span class="line">    <span class="type">void</span> *rx_buf;        <span class="comment">//用于保存接收到的数据。</span></span><br><span class="line">    <span class="type">unsigned</span> len;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>




<h4 id="五、static-int-icm20608-read-regs函数实现"><a href="#五、static-int-icm20608-read-regs函数实现" class="headerlink" title="五、static int icm20608_read_regs函数实现"></a>五、static int icm20608_read_regs函数实现</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> txdata[len];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_message</span> m;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_transfer</span> *t;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_device</span> *spi = (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//片选拉低</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建spi_transfer</span></span><br><span class="line">	t = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步：发送要读取的寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：读取数据</span></span><br><span class="line">    txdata[<span class="number">0</span>] = <span class="number">0xff</span>;</span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 另一种方式替代67-90，通过内核提供的函数  */</span></span><br><span class="line">    data = reg | <span class="number">0x80</span>;</span><br><span class="line">    <span class="built_in">spi_write</span>(spi, &amp;data, <span class="number">1</span>);  <span class="comment">//发送要读取的寄存器地址</span></span><br><span class="line">    <span class="built_in">spi_read</span>(spi, buf, len);   <span class="comment">//读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//片选拉高</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h4 id="六、static-s32-icm20608-write-regs函数实现"><a href="#六、static-s32-icm20608-write-regs函数实现" class="headerlink" title="六、static s32 icm20608_write_regs函数实现"></a>六、static s32 icm20608_write_regs函数实现</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> txdata[len];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_message</span> m;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_transfer</span> *t;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">spi_device</span> *spi = (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//片选拉低</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建spi_transfer</span></span><br><span class="line">	t = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步：发送要写的寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg &amp; ~<span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：读取数据</span></span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spi_message_init</span>(&amp;m);</span><br><span class="line">    <span class="built_in">spi_message_add_tail</span>(t, &amp;m);</span><br><span class="line">    ret = <span class="built_in">spi_sync</span>(spi, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="built_in">kfree</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 另一种方式，通过内核提供的函数  */</span></span><br><span class="line">    data = reg | ~<span class="number">0x80</span>;</span><br><span class="line">    <span class="built_in">spi_write</span>(spi, &amp;data, <span class="number">1</span>);  <span class="comment">//发送要写的寄存器地址</span></span><br><span class="line">    <span class="built_in">spi_write</span>(spi, buf, len);   <span class="comment">//写数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//片选拉高</span></span><br><span class="line">    <span class="built_in">gpio_set_value</span>(dev-&gt;cs_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>linux设备树</title>
    <url>/2024/04/06/linux%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h3 id="5-1-什么是设备树？"><a href="#5-1-什么是设备树？" class="headerlink" title="5.1 什么是设备树？"></a>5.1 什么是设备树？</h3><p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、 IIC 接口上接了哪些设备、 SPI 接口上接了哪些设备等等。</p>
<p>以前的 Linux 内核中 ARM 架构并没有采用设备树。在 Linux 内核源码中大量的 arch&#x2F;arm&#x2F;mach-xxx 和 arch&#x2F;arm&#x2F;plat-xxx 文件夹，这些文件夹里面的文件就是对应平台下的板级信息。<br><strong>后来将这些描述板级硬件信息的内容都从 Linux 内中分离开来，用一个专属的文件格式来描述，这个专属的文件就叫做设备树，文件扩展名为.dts。</strong> 一个 SOC 可以作出很多不同的板子，这些不同的板子肯定是有共同的信息， 将这些共同的信息提取出来作为一个通用的文件，其他的.dts 文件直接引用这个通用文件即可，这个通用文件就是.dtsi 文件，类似于 C 语言中的头文件。一般.dts 描述板级信息(也就是开发板上有哪些 IIC 设备、 SPI 设备等)， .dtsi 描述 SOC 级信息(也就是 SOC 有几个 CPU、主频是多少、各个外设控制器信息等)。<br>这个就是设备树的由来，简而言之就是， Linux 内核中 ARM 架构下有太多的冗余的垃圾板级信息文件，导致 linus 震怒，然后 ARM 社区引入了设备树。</p>
<h3 id="5-2-DTS、-DTB-和-DTC"><a href="#5-2-DTS、-DTB-和-DTC" class="headerlink" title="5.2 DTS、 DTB 和 DTC"></a>5.2 DTS、 DTB 和 DTC</h3><p>设备树源文件扩展名为.dts，但是我们在前面移植 Linux 的时候却一直在使用.dtb 文件，那么 DTS 和 DTB 这两个文件是什么关系呢？ DTS 是设备树源码文件， DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要用到 DTC 工具。</p>
<h3 id="5-3-DTS-语法"><a href="#5-3-DTS-语法" class="headerlink" title="5.3 DTS 语法"></a>5.3 DTS 语法</h3><h4 id="5-3-1-dtsi-头文件"><a href="#5-3-1-dtsi-头文件" class="headerlink" title="5.3.1 .dtsi 头文件"></a>5.3.1 .dtsi 头文件</h4><p>和 C 语言一样，设备树也支持头文件，设备树的头文件扩展名为.dtsi。在 imx6ull-alientekemmc.dts 中有如下所示内容：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dt-bindings/input/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ull.dtsi&quot;</span></span></span><br></pre></td></tr></table></figure></div>
<p>一般.dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、 IIC 等等。</p>
<h4 id="5-3-2-设备节点"><a href="#5-3-2-设备节点" class="headerlink" title="5.3.2 设备节点"></a>5.3.2 设备节点</h4><p>设备树是采用树形结构来描述板子上的设备信息的文件，每个设备都是一个节点，叫做设备节点，每个节点都通过一些属性信息来描述节点信息，属性就是键—值对。</p>
<h4 id="5-3-3-标准属性"><a href="#5-3-3-标准属性" class="headerlink" title="5.3.3 标准属性"></a>5.3.3 标准属性</h4><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性， Linux 下的很多外设驱动都会使用这些标准属性。</p>
<h5 id="1、-compatible-属性"><a href="#1、-compatible-属性" class="headerlink" title="1、 compatible 属性"></a>1、 compatible 属性</h5><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！ compatible 属性的值是一个字符串列表， compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序， compatible 属性的值格式如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;manufacturer,model&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>其中 manufacturer 表示厂商， model 一般是模块对应的驱动名字。比如 imx6ull-alientekemmc.dts 中 sound 节点是 I.MX6U-ALPHA 开发板的音频设备节点， I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960， sound 节点的 compatible 属性值如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,<span class="string">&quot;fsl,imx-audio-wm8960&quot;</span>;</span><br></pre></td></tr></table></figure></div>
<p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960”，其中“fsl”表示厂商是飞思卡尔，“imx6ul-evk-wm8960”和“imx-audio-wm8960”表示驱动模块名字。** sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。**<br><strong>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。比如在文件 imx-wm8960.c 中有如下内容：</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">imx_wm8960_dt_ids</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;fsl,imx-audio-wm8960&quot;</span>, &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, imx_wm8960_dt_ids);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">imx_wm8960_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;imx-wm8960&quot;</span>,</span><br><span class="line">        .pm = &amp;snd_soc_pm_ops,</span><br><span class="line">        .of_match_table = imx_wm8960_dt_ids,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = imx_wm8960_probe,</span><br><span class="line">    .remove = imx_wm8960_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>数组 imx_wm8960_dt_ids 就是 imx-wm8960.c 这个驱动文件的匹配表，此匹配表只有一个匹配值“fsl,imx-audio-wm8960”。如果在设备树中有哪个节点的 compatible 属性值与此相等，那么这个节点就会使用此驱动文件。<br>wm8960 采用了 platform_driver 驱动模式，关于 platform_driver 驱动后面会讲解。此行设置.of_match_table 为 imx_wm8960_dt_ids，也就是设置这个 platform_driver 所使用的OF 匹配表。</p>
<h5 id="2、-model-属性"><a href="#2、-model-属性" class="headerlink" title="2、 model 属性"></a>2、 model 属性</h5><p>model 属性值也是一个字符串，一般 model 属性描述设备模块信息，比如名字什么的，比如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">model = <span class="string">&quot;wm8960-audio&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="3、-status-属性"><a href="#3、-status-属性" class="headerlink" title="3、 status 属性"></a>3、 status 属性</h5><p>status 属性看名字就知道是和设备状态有关的， status 属性值也是字符串，字符串是设备的状态信息，可选的状态如下所示：</p>
<ol>
<li>“okay”：表明设备是可操作的。</li>
<li>“disabled”：表明设备当前是不可操作的，但是在未来可以变为可操作的。</li>
<li>“fail”：表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得可操作。</li>
<li>“fail-sss”：含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</li>
</ol>
<h5 id="4、-address-cells-和-size-cells-属性"><a href="#4、-address-cells-和-size-cells-属性" class="headerlink" title="4、 #address-cells 和#size-cells 属性"></a>4、 #address-cells 和#size-cells 属性</h5><p>这两个属性的值都是无符号 32 位整形， #address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。 #address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)， #size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 #address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度， reg 属性的格式一为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</span><br></pre></td></tr></table></figure></div>
<p>每个“address length”组合表示一个地址范围，其中 address 是起始地址， length 是地址长度， #address-cells 表明 address 这个数据所占用的字长， #size-cells 表明 length 这个数据所占用的字长。</p>
<h5 id="5、-reg-属性"><a href="#5、-reg-属性" class="headerlink" title="5、 reg 属性"></a>5、 reg 属性</h5><p>reg 属性前面已经提到过了， reg 属性的值一般是(address， length)对。 reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息。</p>
<h4 id="5-3-4-根节点-compatible-属性"><a href="#5-3-4-根节点-compatible-属性" class="headerlink" title="5.3.4 根节点 compatible 属性"></a>5.3.4 根节点 compatible 属性</h4><p>每个节点都有 compatible 属性，根节点“&#x2F;”也不例外， imx6ull-alientek-emmc.dts 文件中根节点的 compatible 属性内容如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;Freescale i.MX6 ULL 14x14 EVK Board&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看出， compatible 有两个值：“fsl,imx6ull-14x14-evk”和“fsl,imx6ull”。<strong>前面我们说了，设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序</strong>，**通过根节点的 compatible 属性可以知道我们所使用的设备，一般第一个值描述了所使用的硬件设备名字，比如这里使用的是“imx6ull-14x14-evk”这个设备，第二个值描述了设备所使用的 SOC，比如这里使用的是“imx6ull”这颗 SOC。 **Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。</p>
<h4 id="5-3-5-向节点追加或修改内容"><a href="#5-3-5-向节点追加或修改内容" class="headerlink" title="5.3.5 向节点追加或修改内容"></a>5.3.5 向节点追加或修改内容</h4><p>产品开发过程中可能面临着频繁的需求更改，比如第一版硬件上有一个 IIC 接口的六轴芯片 MPU6050，第二版硬件又要把这个 MPU6050 更换为 MPU9250 等。一旦硬件修改了，我们就要同步的修改设备树文件，毕竟设备树是描述板子硬件信息的文件。假设现在有个六轴芯片fxls8471， fxls8471 要接到 I.MX6U-ALPHA 开发板的 I2C1 接口上，那么相当于需要在 i2c1 这个节点上添加一个 fxls8471 子节点。先看一下 I2C1 接口对应的节点，打开文件 imx6ull.dtsi 文件，找到如下所示内容：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>现在要在 i2c1 节点下创建一个子节点，这个子节点就是 fxls8471，最简单的方法就是在 i2c1 下直接添加一个名为 fxls8471 的子节点，如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">    compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">    status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fxls8471 子节点</span></span><br><span class="line">    fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>添加的 fxls8471 这个芯片对应的子节点。但是这样会有个问题！ i2c1 节点是定义在 imx6ull.dtsi 文件中的，而 imx6ull.dtsi 是设备树头文件，其他所有使用到 I.MX6ULL这颗 SOC 的板子都会引用 imx6ull.dtsi 这个文件。直接在 i2c1 节点中添加 fxls8471 就相当于在其他的所有板子上都添加了 fxls8471 这个设备，但是其他的板子并没有这个设备啊！因此，按照示例代码这样写肯定是不行的。<br>这里就要引入另外一个内容，那就是如何向节点追加数据，我们现在要解决的就是如何向i2c1 节点追加一个名为 fxls8471 的子节点，而且不能影响到其他使用到 I.MX6ULL 的板子。I.MX6U-ALPHA 开发板使用的设备树文件为 imx6ull-alientek-emmc.dts，因此我们需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line"><span class="comment">/* 要追加或修改的内容 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>第 1 行， &amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。打开 imx6ull-alientek-emmc.dts，找到如下所示内容：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">    clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">    mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">        position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">        position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>向 i2c1 节点添加&#x2F;修改数据，比如第 2 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第5 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 7-11 行， i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br>第 13-18 行， i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片。<br>因为示例代码中的内容是 imx6ull-alientek-emmc.dts 这个文件内的，所以不会对使用 I.MX6ULL 这颗 SOC 的其他板子造成任何影响。这个就是向节点追加或修改内容，重点就是通过&amp;label 来访问节点，然后直接在里面编写要追加或者修改的内容。</p>
<h3 id="5-4-设备树在系统中的体现"><a href="#5-4-设备树在系统中的体现" class="headerlink" title="5.4 设备树在系统中的体现"></a>5.4 设备树在系统中的体现</h3><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹。</p>
<h3 id="5-5-设备树常用-OF-操作函数"><a href="#5-5-设备树常用-OF-操作函数" class="headerlink" title="5.5 设备树常用 OF 操作函数"></a>5.5 设备树常用 OF 操作函数</h3><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的0X02005482 和 0X400 这两个值，然后初始化外设。 Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p>
<h4 id="5-5-1-查找节点的-OF-函数"><a href="#5-5-1-查找节点的-OF-函数" class="headerlink" title="5.5.1 查找节点的 OF 函数"></a>5.5.1 查找节点的 OF 函数</h4><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。 Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 节点名字 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type; <span class="comment">/* 设备类型 */</span></span><br><span class="line">    phandle phandle;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *full_name; <span class="comment">/* 节点全名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span> <span class="comment">/* 属性 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span> <span class="comment">/* removed 属性 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span> <span class="comment">/* 父节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span> <span class="comment">/* 子节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path_component_name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p>
<h5 id="1、-of-find-node-by-name-函数"><a href="#1、-of-find-node-by-name-函数" class="headerlink" title="1、 of_find_node_by_name 函数"></a>1、 of_find_node_by_name 函数</h5><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">                                         <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>name：要查找的节点名字。<br>返回值： 找到的节点，如果为 NULL 表示查找失败。</p>
<h5 id="2、-of-find-node-by-type-函数"><a href="#2、-of-find-node-by-type-函数" class="headerlink" title="2、 of_find_node_by_type 函数"></a>2、 of_find_node_by_type 函数</h5><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。<br>返回值： 找到的节点，如果为 NULL 表示查找失败。</p>
<h5 id="3、-of-find-compatible-node-函数"><a href="#3、-of-find-compatible-node-函数" class="headerlink" title="3、 of_find_compatible_node 函数"></a>3、 of_find_compatible_node 函数</h5><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">                                            <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">                                            <span class="type">const</span> <span class="type">char</span> *compatible)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。<br>compatible： 要查找的节点所对应的 compatible 属性列表。返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h5 id="4、-of-find-matching-node-and-match-函数"><a href="#4、-of-find-matching-node-and-match-函数" class="headerlink" title="4、 of_find_matching_node_and_match 函数"></a>4、 of_find_matching_node_and_match 函数</h5><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。<br>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。<br>match： 找到的匹配的 of_device_id。<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h5 id="5、-of-find-node-by-path-函数"><a href="#5、-of-find-node-by-path-函数" class="headerlink" title="5、 of_find_node_by_path 函数"></a>5、 of_find_node_by_path 函数</h5><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>path：带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个节点的全路径。<br>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="5-5-2-查找父-子节点的-OF-函数"><a href="#5-5-2-查找父-子节点的-OF-函数" class="headerlink" title="5.5.2 查找父&#x2F;子节点的 OF 函数"></a>5.5.2 查找父&#x2F;子节点的 OF 函数</h4><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p>
<h5 id="1、-of-get-parent-函数"><a href="#1、-of-get-parent-函数" class="headerlink" title="1、 of_get_parent 函数"></a>1、 of_get_parent 函数</h5><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>node：要查找的父节点的节点。返回值： 找到的父节点。</p>
<h5 id="2、-of-get-next-child-函数"><a href="#2、-of-get-next-child-函数" class="headerlink" title="2、 of_get_next_child 函数"></a>2、 of_get_next_child 函数</h5><p>of_get_next_child 函数用迭代的方式查找子节点，函数原型如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node,</span></span><br><span class="line"><span class="params">                                      <span class="keyword">struct</span> device_node *prev)</span></span><br></pre></td></tr></table></figure></div>
<p>函数参数和返回值含义如下：<br>node：父节点。<br>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。<br>返回值： 找到的下一个子节点。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>zr的第一篇博客文章</title>
    <url>/2023/12/14/zr%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>zr os!</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理系统</title>
    <url>/2024/01/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、开启分页机制"><a href="#一、开启分页机制" class="headerlink" title="一、开启分页机制"></a>一、开启分页机制</h3><h4 id="1、准备好页目录及页表"><a href="#1、准备好页目录及页表" class="headerlink" title="1、准备好页目录及页表"></a>1、准备好页目录及页表</h4><ol>
<li>清空页目录：首先清空了页目录占用的空间，将每个字节都设置为0，确保页目录表是空的。</li>
<li>创建页目录项（PDE）：<br>  a. 将低1GB的虚拟地址空间映射到物理地址空间，方便用户进程和内核的访问。<br>  b. 创建了一个PDE来表示这个映射，将这个PDE写入到页目录表的第0个和倒数第二个目录项中。<br>  c. 最后一个PDE被设置为指向页目录表自身的地址，形成了页目录表的循环结构，以便操作系统可以通过虚拟地址访问页目录表。</li>
<li>创建页目录表（PTE）：<br>  a. 填充了第一个页表。这个页表将虚拟地址的低1GB映射到物理地址的低1GB，这样用户空间的进程可以访问到这部分物理地址空间。<br>  b. 创建了内核其他页表的PDE，将这些页表映射到页目录表的后续项中，从而映射了内核的其他地址空间。</li>
</ol>
<h4 id="2、重启加载-GDT"><a href="#2、重启加载-GDT" class="headerlink" title="2、重启加载 GDT"></a>2、重启加载 GDT</h4><p>重启加载 GDT 的主要目的是为了确保在分页机制启用后，GDT 中的段描述符已经正确地反映了新的内存布局和内核的位置。这是因为分页机制的启用会导致内存的地址映射发生变化，原来的地址和段基址可能已经不再有效。因此，需要更新 GDT 中的段描述符，以正确地映射内核和其他重要的段。</p>
<h4 id="3、启用分页机制"><a href="#3、启用分页机制" class="headerlink" title="3、启用分页机制"></a>3、启用分页机制</h4><p>将页目录表的物理地址赋给 cr3 寄存器，开启 cr0 寄存器的 pg 位，重新加载 GDT</p>
<h3 id="二、实现字符串函数"><a href="#二、实现字符串函数" class="headerlink" title="二、实现字符串函数"></a>二、实现字符串函数</h3><h4 id="1、memset-用于将一段内存区域的内容全部设置为指定的值。"><a href="#1、memset-用于将一段内存区域的内容全部设置为指定的值。" class="headerlink" title="1、memset 用于将一段内存区域的内容全部设置为指定的值。"></a>1、memset 用于将一段内存区域的内容全部设置为指定的值。</h4><h4 id="2、memcpy-用于将源内存区域的内容复制到目标内存区域。"><a href="#2、memcpy-用于将源内存区域的内容复制到目标内存区域。" class="headerlink" title="2、memcpy 用于将源内存区域的内容复制到目标内存区域。"></a>2、memcpy 用于将源内存区域的内容复制到目标内存区域。</h4><h4 id="3、memcmp-用于比较两个内存区域的内容是否相等。"><a href="#3、memcmp-用于比较两个内存区域的内容是否相等。" class="headerlink" title="3、memcmp 用于比较两个内存区域的内容是否相等。"></a>3、memcmp 用于比较两个内存区域的内容是否相等。</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将 dst_起始的 size 个字节置为 value */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">uint8_t</span> value, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = (<span class="type">uint8_t</span>*)dst_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">    *dst++ = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 src_起始的 size 个字节复制到 dst_ */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst_, <span class="type">const</span> <span class="type">void</span>* src_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    ASSERT(dst_ != <span class="literal">NULL</span> &amp;&amp; src_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint8_t</span>* dst = dst_;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* src = src_;</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)</span><br><span class="line">    *dst++ = *src++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连续比较以地址 a_和地址 b_开头的 size 个字节，若相等则返回 0，</span></span><br><span class="line"><span class="comment">若 a_大于 b_，返回+1，否则返回−1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* a = a_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* b = b_;</span><br><span class="line">    ASSERT(a != <span class="literal">NULL</span> || b != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*a != *b) &#123;</span><br><span class="line">            <span class="keyword">return</span> *a &gt; *b ? <span class="number">1</span> : −<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="三、实现位图bitmap的相关接口函数"><a href="#三、实现位图bitmap的相关接口函数" class="headerlink" title="三、实现位图bitmap的相关接口函数"></a>三、实现位图bitmap的相关接口函数</h3><h4 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h4><p>位图相当于一组资源的映射。位图中的每一位和被管理的单位资源都是一对一的关系，故位图主要用于管理容量较大的资源。</p>
<h4 id="2、bitmap-init-struct-bitmap-btmp"><a href="#2、bitmap-init-struct-bitmap-btmp" class="headerlink" title="2、bitmap_init(struct bitmap* btmp)"></a>2、bitmap_init(struct bitmap* btmp)</h4><p>函数用于初始化位图，将位图中所有位都置为 0。<br>使用 memset 函数将位图内存块的所有内容都初始化为 0。</p>
<h4 id="3、bitmap-scan-test-struct-bitmap-btmp-uint32-t-bit-idx"><a href="#3、bitmap-scan-test-struct-bitmap-btmp-uint32-t-bit-idx" class="headerlink" title="3、bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx)"></a>3、bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx)</h4><p>函数用于判断位图中某一位的状态。<br>首先根据 bit_idx 计算出位所在的字节索引 byte_idx 和位索引 bit_odd。<br>使用位操作，将对应位的状态取出并返回。</p>
<h4 id="4、bitmap-scan-struct-bitmap-btmp-uint32-t-cnt"><a href="#4、bitmap-scan-struct-bitmap-btmp-uint32-t-cnt" class="headerlink" title="4、bitmap_scan(struct bitmap* btmp, uint32_t cnt)"></a>4、bitmap_scan(struct bitmap* btmp, uint32_t cnt)</h4><p>函数用于设置位图中某一位的状态。</p>
<ol>
<li>逐字节比较找到第一个非满字节</li>
<li>查找连续的空闲位</li>
<li>返回空闲位的起始下标<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitmap_scan</span><span class="params">(<span class="keyword">struct</span> bitmap* btmp, <span class="type">uint32_t</span> cnt)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> idx_byte = <span class="number">0</span>; <span class="comment">// 用于记录空闲位所在的字节</span></span><br><span class="line">    <span class="comment">/* 先逐字节比较，蛮力法 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len)) &#123;</span><br><span class="line">        <span class="comment">/* 1 表示该位已分配，若为 0xff，则表示该字节内已无空闲位，向下一字节继续找 */</span></span><br><span class="line">        idx_byte++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len) &#123; <span class="comment">// 若该内存池找不到可用空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若在位图数组范围内的某字节内找到了空闲位</span></span><br><span class="line"><span class="comment">     * 在该字节内逐位比对，返回空闲位的索引。 */</span></span><br><span class="line">    <span class="type">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 和 btmp-&gt;bits[idx_byte]这个字节逐位对比 */</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte]) &#123;</span><br><span class="line">        idx_bit++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit; <span class="comment">// 空闲位在位图内的下标</span></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start); <span class="comment">// 记录还有多少位可以判断</span></span><br><span class="line">    <span class="type">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">1</span>; <span class="comment">// 用于记录找到的空闲位的个数</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>; <span class="comment">// 先将其置为 -1，若找不到连续的位就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bitmap_scan_test(btmp, next_bit))) &#123; <span class="comment">// 若 next_bit 为 0</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == cnt) &#123; <span class="comment">// 若找到连续的 cnt 个空位</span></span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_bit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="四、实现内存管理系统"><a href="#四、实现内存管理系统" class="headerlink" title="四、实现内存管理系统"></a>四、实现内存管理系统</h3><h3 id="1、vaddr-get："><a href="#1、vaddr-get：" class="headerlink" title="1、vaddr_get："></a>1、vaddr_get：</h3><p>这个函数用于从虚拟地址管理池中获取一定数量的虚拟地址空间。<br>根据传入的内存池类型和页面数量，调用 bitmap_scan 和 bitmap_set 来管理虚拟地址的分配情况。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> vaddr_start = <span class="number">0</span>, bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL) &#123;</span><br><span class="line">        <span class="comment">// 在 kernel_vaddr 的虚拟地址位图中找到一段连续的虚拟地址</span></span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span> (bit_idx_start == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置这段虚拟地址已被占用</span></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + (cnt++), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算起始虚拟地址</span></span><br><span class="line">        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对用户内存池的处理，这部分没有具体实现，根据需要补充</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、palloc"><a href="#2、palloc" class="headerlink" title="2、palloc"></a>2、palloc</h4><p>这个函数用于从指定的内存池中分配一页的物理内存。<br>通过调用 bitmap_scan 和 bitmap_set 来管理物理页的分配情况。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">palloc</span><span class="params">(<span class="keyword">struct</span> pool* m_pool)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bit_idx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置这个位已被占用</span></span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算物理地址</span></span><br><span class="line">    <span class="type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="3、page-table-add"><a href="#3、page-table-add" class="headerlink" title="3、page_table_add"></a>3、page_table_add</h4><p>这个函数用于将虚拟地址和物理地址的映射添加到页表中。<br>根据传入的虚拟地址，计算出页表和页目录项的指针，然后将物理地址和相关标志写入页表中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)_vaddr, page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">    <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">    <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据虚拟地址计算出对应的页表项（PTE）和页目录项（PDE）。</span></span><br><span class="line"><span class="comment">   如果页目录项存在（已经分配），则直接将物理地址填入对应的页表项。</span></span><br><span class="line"><span class="comment">   如果页目录项不存在（未分配），则先分配一个页目录项，然后将对应的页表项清零，并填入物理地址。 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; <span class="number">0x00000001</span>) &#123;</span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        <span class="keyword">if</span> (!(*pte &amp; <span class="number">0x00000001</span>))</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            PANIC(<span class="string">&quot;pte repeat&quot;</span>);</span><br><span class="line">            *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line">        *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4、malloc-page"><a href="#4、malloc-page" class="headerlink" title="4、malloc_page"></a>4、malloc_page</h4><p>这个函数是在内核中用于分配连续多页的虚拟地址和物理内存的函数。并且建立虚拟地址和物理地址之间的映射关系，从而为进程提供可用的内存空间。<br>在实现中调用了 vaddr_get 和 palloc，并在分配页面后调用 page_table_add 来建立映射关系。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="type">uint32_t</span> pg_cnt)</span> &#123;</span><br><span class="line">    ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>* vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span> (vaddr_start == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)vaddr_start, cnt = pg_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span>* page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span> (page_phyaddr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        page_table_add((<span class="type">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">        vaddr += PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理系统的异常处理</title>
    <url>/2024/03/01/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="位图保存时机："><a href="#位图保存时机：" class="headerlink" title="位图保存时机："></a>位图保存时机：</h3><ol>
<li>位图保存的时机通常取决于系统的需求和性能要求。一般来说，位图的保存应该在内存分配或释放操作之后立即进行。这样可以确保位图的状态与实际内存的状态保持同步，并且在系统异常或掉电等情况下可以快速恢复。</li>
<li>另外，可以在位图发生较大变化时进行定期保存，以减少保存操作的频率，提高系统性能。</li>
</ol>
<h3 id="系统宕机处理："><a href="#系统宕机处理：" class="headerlink" title="系统宕机处理："></a>系统宕机处理：</h3><ol>
<li>当系统遇到宕机或异常情况时，位图的保存状态可能会受到影响。为了防止数据丢失或损坏，可以在系统启动时检查位图的一致性，并尝试恢复到上一次保存的状态。</li>
<li>在系统设计阶段，可以采用类似于事务处理的机制，确保位图和实际内存分配状态的一致性，从而减少系统宕机时的影响。</li>
</ol>
<h3 id="内存管理对整片内存擦除次数的保护机制："><a href="#内存管理对整片内存擦除次数的保护机制：" class="headerlink" title="内存管理对整片内存擦除次数的保护机制："></a>内存管理对整片内存擦除次数的保护机制：</h3><p>在嵌入式系统中，内存的擦除次数是需要注意的问题，特别是对于闪存等具有有限擦写寿命的存储介质。为了保护整片内存的擦除次数，可以采取以下措施：</p>
<ol>
<li>实现 wear leveling（磨损平衡）技术，通过均衡地分配擦写操作，延长存储介质的使用寿命。</li>
<li>实施垃圾回收机制，定期清理不再使用的内存块，减少擦写次数。</li>
<li>使用 ECC（错误校正码）或其他数据完整性校验技术，确保数据的可靠性，减少由于擦写错误引起的数据损坏。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式中常用C程序</title>
    <url>/2024/02/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E5%B8%B8%E7%94%A8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1、十六进制字符转整型数字"><a href="#1、十六进制字符转整型数字" class="headerlink" title="1、十六进制字符转整型数字"></a>1、十六进制字符转整型数字</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">功能：将16进制的字符串转换为10进制的数字</span></span><br><span class="line"><span class="comment">常用的函数有atoi,atol,他们都是将10进制的数字字符串转换为int或是long类型，所以在有些情况下不适用。</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">//该函数用于将单个十六进制的字符转为10进制数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c2i</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果是数字，则用数字的ASCII码减去48, 如果ch = &#x27;2&#x27; ,则 &#x27;2&#x27; - 48 = 2  </span></span><br><span class="line">    <span class="comment">// isdigit(ch)用于判断字符 ch 是否是一个数字字符的函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))  </span><br><span class="line">       <span class="keyword">return</span> ch - <span class="number">48</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果是字母，但不是A~F,a~f则返回  </span></span><br><span class="line">    <span class="keyword">if</span>( ch &lt; <span class="string">&#x27;A&#x27;</span> || (ch &gt; <span class="string">&#x27;F&#x27;</span> &amp;&amp; ch &lt; <span class="string">&#x27;a&#x27;</span>) || ch &gt; <span class="string">&#x27;z&#x27;</span> )  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果是大写字母，则用数字的ASCII码减去55, 如果ch = &#x27;A&#x27; ,则 &#x27;A&#x27; - 55 = 10  </span></span><br><span class="line">    <span class="comment">// 如果是小写字母，则用数字的ASCII码减去87, 如果ch = &#x27;a&#x27; ,则 &#x27;a&#x27; - 87 = 10  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))  </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">isupper</span>(ch) ? ch - <span class="number">55</span> : ch - <span class="number">87</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//该函数用于将16进制字符串转为十进制数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    <span class="type">int</span> bits;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">char</span> str[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == hex) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input para error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果输入的字符串以 &quot;0x&quot; 或 &quot;0X&quot; 开头，则去除这个前缀</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="string">&#x27;0&#x27;</span>== hex[<span class="number">0</span>]) &amp;&amp; ((<span class="string">&#x27;X&#x27;</span> == hex[<span class="number">1</span>]) || (<span class="string">&#x27;x&#x27;</span> == hex[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, &amp;hex[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, hex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input num = %s \n&quot;</span>, str);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str);  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, temp = <span class="number">0</span>; i &lt; len; i++, temp = <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 调用 c2i 函数将十六进制字符转换为对应的十进制数值</span></span><br><span class="line">        temp = <span class="built_in">c2i</span>( *(str + i) );  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一个十六进制位对应 4 位二进制位，需要左移相应的位数</span></span><br><span class="line">        bits = (len - i - <span class="number">1</span>) * <span class="number">4</span>;  </span><br><span class="line">        temp = temp &lt;&lt; bits;  </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用按位或操作将每个字节的值合并到最终结果中</span></span><br><span class="line">        num = num | temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="2、字符串转整型"><a href="#2、字符串转整型" class="headerlink" title="2、字符串转整型"></a>2、字符串转整型</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment">功能：将正常输入的16进制或是10进制的字符串转换为int数据类型。</span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">String2int</span><span class="params">(<span class="type">char</span> *strChar)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pstrCmp1 = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pstrCmp2 = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> uiValue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == strChar)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查字符串的长度，并且在长度小于等于 0 的情况下返回 -1。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= (len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)strChar)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strstr是查找子字符串的函数调用，判断字符串是否以 &quot;0x&quot; 或 &quot;0X&quot; 开头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != (pstr = <span class="built_in">strstr</span>(strChar, <span class="string">&quot;0x&quot;</span>)) || <span class="literal">NULL</span> != (pstr = <span class="built_in">strstr</span>(strChar, <span class="string">&quot;0X&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">// 将指针 pstr 移动到真正的十六进制数的起始位置（去掉 &quot;0x&quot; 或 &quot;0X&quot;）</span></span><br><span class="line">        pstr = (<span class="type">char</span> *)strChar + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt;= (len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstr)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = (len - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pstr[i] &gt; <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果字符大于 &#x27;F&#x27;，说明是小写十六进制字符，会在 pstrCmp2 中查找对应字符的位置 t，然后将对应的值左移 j 位（每个十六进制数需要占据 4 位），并将这个值按位或（|）到 uiValue 中。</span></span><br><span class="line">                <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstrCmp2); t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pstrCmp2[t] == pstr[i])</span><br><span class="line">                        uiValue |= (t &lt;&lt; (j++ * <span class="number">4</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果字符不大于 &#x27;F&#x27;，说明是大写十六进制字符，会在 pstrCmp1 中查找对应字符的位置 t，然后同样左移 j 位并按位或到 uiValue 中。</span></span><br><span class="line">                <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)pstrCmp1); t++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pstrCmp1[t] == pstr[i])</span><br><span class="line">                        uiValue |= (t &lt;&lt; (j++ * <span class="number">4</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 atoi 函数将其转换为整数</span></span><br><span class="line">        uiValue = <span class="built_in">atoi</span>((<span class="type">const</span> <span class="type">char</span> *)strChar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uiValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
</search>
